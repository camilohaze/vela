//! JSON Decorators for automatic serialization
//!
//! This module provides decorator-based JSON serialization for Vela types.
//! Decorators allow automatic generation of serialization/deserialization code.

use crate::json::{JsonValue, JsonSerializable};
use std::collections::HashMap;

/// Configuration for JSON decorators
#[derive(Debug, Clone)]
pub struct JsonDecoratorConfig {
    /// Fields to include in serialization
    pub include: Option<Vec<String>>,
    /// Fields to exclude from serialization
    pub exclude: Option<Vec<String>>,
    /// Field renaming map (original -> json name)
    pub rename: HashMap<String, String>,
    /// Default values for fields
    pub default_values: HashMap<String, JsonValue>,
}

impl Default for JsonDecoratorConfig {
    fn default() -> Self {
        Self {
            include: None,
            exclude: None,
            rename: HashMap::new(),
            default_values: HashMap::new(),
        }
    }
}

/// Field-level decorator configuration
#[derive(Debug, Clone)]
pub struct JsonFieldDecorator {
    /// Skip this field in serialization
    pub skip: bool,
    /// Rename this field in JSON
    pub rename: Option<String>,
    /// Default value for this field
    pub default: Option<JsonValue>,
    /// Flatten nested object
    pub flatten: bool,
}

impl Default for JsonFieldDecorator {
    fn default() -> Self {
        Self {
            skip: false,
            rename: None,
            default: None,
            flatten: false,
        }
    }
}

/// Trait for types with JSON decorator support
pub trait JsonDecorated {
    /// Get the decorator configuration for this type
    fn json_config() -> JsonDecoratorConfig;

    /// Get field configurations
    fn field_configs() -> HashMap<String, JsonFieldDecorator>;

    /// Serialize with decorator rules applied
    fn to_json_decorated(&self) -> String {
        self.to_json_value_decorated().to_json()
    }

    /// Serialize to JsonValue with decorator rules applied
    fn to_json_value_decorated(&self) -> JsonValue;
}

/// Macro to implement JsonDecorated for a type
#[macro_export]
macro_rules! impl_json_decorated {
    ($type:ty, $config:expr, $field_configs:expr) => {
        impl JsonDecorated for $type {
            fn json_config() -> JsonDecoratorConfig {
                $config
            }

            fn field_configs() -> HashMap<String, JsonFieldDecorator> {
                $field_configs
            }

            fn to_json_value_decorated(&self) -> JsonValue {
                let config = Self::json_config();
                let field_configs = Self::field_configs();
                let mut obj = HashMap::new();

                // This would be generated by the compiler macro
                // For now, return empty object
                JsonValue::Object(obj)
            }
        }

        impl JsonSerializable for $type {
            fn to_json(&self) -> String {
                self.to_json_decorated()
            }

            fn to_json_value(&self) -> JsonValue {
                self.to_json_value_decorated()
            }
        }
    };
}

/// Helper functions for decorator processing
pub mod helpers {
    use super::*;

    /// Apply include/exclude filters to field list
    pub fn filter_fields(
        all_fields: &[String],
        include: &Option<Vec<String>>,
        exclude: &Option<Vec<String>>,
    ) -> Vec<String> {
        let mut fields = if let Some(include_list) = include {
            all_fields
                .iter()
                .filter(|f| include_list.contains(f))
                .cloned()
                .collect()
        } else {
            all_fields.to_vec()
        };

        if let Some(exclude_list) = exclude {
            fields.retain(|f| !exclude_list.contains(f));
        }

        fields
    }

    /// Apply field renaming
    pub fn apply_renaming(
        field_name: &str,
        rename_map: &HashMap<String, String>,
        field_decorator: &JsonFieldDecorator,
    ) -> String {
        if let Some(rename) = &field_decorator.rename {
            rename.clone()
        } else if let Some(mapped) = rename_map.get(field_name) {
            mapped.clone()
        } else {
            field_name.to_string()
        }
    }

    /// Check if field should be skipped
    pub fn should_skip_field(
        field_name: &String,
        field_decorator: &JsonFieldDecorator,
        exclude_list: &Option<Vec<String>>,
    ) -> bool {
        field_decorator.skip ||
        exclude_list.as_ref().map_or(false, |list| list.contains(field_name))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_decorator_config_default() {
        let config = JsonDecoratorConfig::default();
        assert!(config.include.is_none());
        assert!(config.exclude.is_none());
        assert!(config.rename.is_empty());
        assert!(config.default_values.is_empty());
    }

    #[test]
    fn test_field_decorator_default() {
        let decorator = JsonFieldDecorator::default();
        assert!(!decorator.skip);
        assert!(decorator.rename.is_none());
        assert!(decorator.default.is_none());
        assert!(!decorator.flatten);
    }

    #[test]
    fn test_filter_fields_include() {
        let all_fields = vec!["a".to_string(), "b".to_string(), "c".to_string()];
        let include = Some(vec!["a".to_string(), "c".to_string()]);
        let exclude = None;

        let filtered = helpers::filter_fields(&all_fields, &include, &exclude);
        assert_eq!(filtered, vec!["a", "c"]);
    }

    #[test]
    fn test_filter_fields_exclude() {
        let all_fields = vec!["a".to_string(), "b".to_string(), "c".to_string()];
        let include = None;
        let exclude = Some(vec!["b".to_string()]);

        let filtered = helpers::filter_fields(&all_fields, &include, &exclude);
        assert_eq!(filtered, vec!["a", "c"]);
    }

    #[test]
    fn test_apply_renaming() {
        let mut rename_map = HashMap::new();
        rename_map.insert("oldName".to_string(), "newName".to_string());

        let decorator = JsonFieldDecorator {
            rename: Some("customName".to_string()),
            ..Default::default()
        };

        // Field decorator takes precedence
        let result = helpers::apply_renaming("oldName", &rename_map, &decorator);
        assert_eq!(result, "customName");

        // Fall back to map
        let decorator2 = JsonFieldDecorator::default();
        let result2 = helpers::apply_renaming("oldName", &rename_map, &decorator2);
        assert_eq!(result2, "newName");

        // No renaming
        let result3 = helpers::apply_renaming("field", &rename_map, &decorator2);
        assert_eq!(result3, "field");
    }

    #[test]
    fn test_should_skip_field() {
        let exclude_list = Some(vec!["skipMe".to_string()]);

        let skip_decorator = JsonFieldDecorator {
            skip: true,
            ..Default::default()
        };

        let normal_decorator = JsonFieldDecorator::default();

        assert!(helpers::should_skip_field(&"field".to_string(), &skip_decorator, &None));
        assert!(helpers::should_skip_field(&"skipMe".to_string(), &normal_decorator, &exclude_list));
        assert!(!helpers::should_skip_field(&"normal".to_string(), &normal_decorator, &exclude_list));
    }
}