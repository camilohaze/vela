# ADR-XXX: Foreign Language Bindings for Package Registry

## Estado
✅ Aceptado

## Fecha
2025-12-10

## Contexto
Vela es un lenguaje funcional puro diseñado para ser multi-plataforma, con backends para web (JS/WASM), native (LLVM), y mobile. Sin embargo, para ser viable en el ecosistema real, necesita poder integrar paquetes y librerías existentes de otros lenguajes, especialmente JavaScript para el backend web.

El registry de Vela debe permitir publicar paquetes escritos en Vela puro, pero también bindings a librerías externas. La pregunta surge: ¿cómo implementar un paquete de JS en Vela sin violar el paradigma funcional puro?

## Decisión
Implementaremos un sistema de **Foreign Language Bindings** usando decoradores declarativos que permiten definir interfaces puras en Vela que llaman a código impuro externo de manera controlada.

### Mecanismos de Binding

1. **@js_binding**: Para integración con JavaScript (backend web)
2. **@wasm_binding**: Para módulos WebAssembly
3. **@native_binding**: Para código nativo (C/C++/Rust via FFI)
4. **@dart_binding**: Para Flutter/Dart interop

### Arquitectura
- Los bindings se definen en archivos `.vela` con decoradores especiales
- El compilador genera código glue que mantiene la pureza funcional
- Los bindings son tratados como "efectos" controlados, similares a `effect` en el sistema reactivo

## Consecuencias

### Positivas
- **Reutilización de ecosistemas**: Acceso a npm, crates.io, pub.dev, etc.
- **Adopción más rápida**: Desarrolladores pueden migrar gradualmente
- **Multi-plataforma real**: Integración nativa con plataformas objetivo
- **Pureza mantenida**: Los bindings son "black boxes" con contratos puros

### Negativas
- **Complejidad adicional**: Sistema de bindings aumenta complejidad del compilador
- **Riesgo de impureza**: Mal uso puede introducir side effects no controlados
- **Mantenimiento**: Necesidad de mantener bindings actualizados
- **Performance**: Overhead de interop entre lenguajes

## Alternativas Consideradas

### 1. Solo paquetes nativos en Vela
**Descripción**: Todos los paquetes deben reescribirse en Vela puro.
**Rechazada porque**: Impráctico - perderíamos acceso a ecosistemas maduros como lodash, axios, etc.

### 2. Transpilación automática
**Descripción**: Convertir código JS/TS a Vela automáticamente.
**Rechazada porque**: Imposible mantener pureza funcional y semántica correcta.

### 3. Runtime interop sin bindings
**Descripción**: Llamadas directas a JS desde Vela runtime.
**Rechazada porque**: Violaría pureza funcional y haría código no-portable.

## Implementación

### Ejemplo de Binding JS

```vela
// bindings/js/lodash.vela
@js_binding("lodash")
module Lodash {
  @pure
  fn chunk<T>(array: List<T>, size: Number) -> List<List<T>> {
    // Contract: divide array en chunks de tamaño size
    // Implementation: calls lodash.chunk via JS interop
  }
  
  @pure  
  fn flatten<T>(array: List<List<T>>) -> List<T> {
    // Contract: aplana array anidado
    // Implementation: calls lodash.flatten
  }
}
```

### Código Glue Generado (JS Backend)

```javascript
// Generated by Vela compiler
const lodash = require('lodash');

function vela_chunk(array, size) {
  return lodash.chunk(array, size);
}

function vela_flatten(array) {
  return lodash.flatten(array);
}
```

### Uso en Vela

```vela
import 'bindings:js/lodash'

fn processData(data: List<Number>) -> List<List<Number>> {
  chunks = Lodash.chunk(data, 3)
  return chunks.map(chunk => chunk.filter(x => x > 0))
}
```

## Referencias
- Jira: TASK-103 (vela install), EPIC-10 (Web Backend)
- Documentación: docs/architecture/ADR-XXX.md
- Código: src/compiler/bindings/, runtime/js/interop/

## Implementación
Ver código en: `src/compiler/bindings/`, `runtime/js/interop/`
Tests en: `tests/unit/test_bindings.rs`