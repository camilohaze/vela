# ADR-XXX: Foreign Language Bindings for Package Registry

## Estado
 Propuesto

## Fecha
2025-12-10

## Contexto
Vela es un lenguaje funcional puro dise帽ado para ser multi-plataforma, con backends para web (JS/WASM), native (LLVM), y mobile. Sin embargo, para ser viable en el ecosistema real, necesita poder integrar paquetes y librer铆as existentes de otros lenguajes, especialmente JavaScript para el backend web.

El registry de Vela debe permitir publicar paquetes escritos en Vela puro, pero tambi茅n bindings a librer铆as externas. La pregunta surge: 驴c贸mo implementar un paquete de JS en Vela sin violar el paradigma funcional puro?

## Decisi贸n
Implementaremos un sistema de **Foreign Language Bindings** usando decoradores declarativos que permiten definir interfaces puras en Vela que llaman a c贸digo impuro externo de manera controlada.

### Mecanismos de Binding

1. **@js_binding**: Para integraci贸n con JavaScript (backend web)
2. **@wasm_binding**: Para m贸dulos WebAssembly
3. **@native_binding**: Para c贸digo nativo (C/C++/Rust via FFI)
4. **@dart_binding**: Para Flutter/Dart interop

### Arquitectura
- Los bindings se definen en archivos `.vela` con decoradores especiales
- El compilador genera c贸digo glue que mantiene la pureza funcional
- Los bindings son tratados como "efectos" controlados, similares a `effect` en el sistema reactivo

## Consecuencias

### Positivas
- **Reutilizaci贸n de ecosistemas**: Acceso a npm, crates.io, pub.dev, etc.
- **Adopci贸n m谩s r谩pida**: Desarrolladores pueden migrar gradualmente
- **Multi-plataforma real**: Integraci贸n nativa con plataformas objetivo
- **Pureza mantenida**: Los bindings son "black boxes" con contratos puros

### Negativas
- **Complejidad adicional**: Sistema de bindings aumenta complejidad del compilador
- **Riesgo de impureza**: Mal uso puede introducir side effects no controlados
- **Mantenimiento**: Necesidad de mantener bindings actualizados
- **Performance**: Overhead de interop entre lenguajes

## Alternativas Consideradas

### 1. Solo paquetes nativos en Vela
**Descripci贸n**: Todos los paquetes deben reescribirse en Vela puro.
**Rechazada porque**: Impr谩ctico - perder铆amos acceso a ecosistemas maduros como lodash, axios, etc.

### 2. Transpilaci贸n autom谩tica
**Descripci贸n**: Convertir c贸digo JS/TS a Vela autom谩ticamente.
**Rechazada porque**: Imposible mantener pureza funcional y sem谩ntica correcta.

### 3. Runtime interop sin bindings
**Descripci贸n**: Llamadas directas a JS desde Vela runtime.
**Rechazada porque**: Violar铆a pureza funcional y har铆a c贸digo no-portable.

## Implementaci贸n

### Ejemplo de Binding JS

```vela
// bindings/js/lodash.vela
@js_binding("lodash")
module Lodash {
  @pure
  fn chunk<T>(array: List<T>, size: Number) -> List<List<T>> {
    // Contract: divide array en chunks de tama帽o size
    // Implementation: calls lodash.chunk via JS interop
  }
  
  @pure  
  fn flatten<T>(array: List<List<T>>) -> List<T> {
    // Contract: aplana array anidado
    // Implementation: calls lodash.flatten
  }
}
```

### C贸digo Glue Generado (JS Backend)

```javascript
// Generated by Vela compiler
const lodash = require('lodash');

function vela_chunk(array, size) {
  return lodash.chunk(array, size);
}

function vela_flatten(array) {
  return lodash.flatten(array);
}
```

### Uso en Vela

```vela
import 'bindings:js/lodash'

fn processData(data: List<Number>) -> List<List<Number>> {
  chunks = Lodash.chunk(data, 3)
  return chunks.map(chunk => chunk.filter(x => x > 0))
}
```

## Referencias
- Jira: TASK-103 (vela install), EPIC-10 (Web Backend)
- Documentaci贸n: docs/architecture/ADR-XXX.md
- C贸digo: src/compiler/bindings/, runtime/js/interop/

## Implementaci贸n
Ver c贸digo en: `src/compiler/bindings/`, `runtime/js/interop/`
Tests en: `tests/unit/test_bindings.rs`