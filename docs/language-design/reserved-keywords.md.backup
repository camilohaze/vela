# Vela Reserved Keywords

**Version:** 0.1.0 (Phase 0 - Sprint 4) - CORRECTED  
**Status:** Specification  
**Date:** 2025-11-30  
**Paradigm:** FUNCTIONAL PROGRAMMING (Pure Functional)

## Overview

This document defines the complete set of reserved keywords (palabras reservadas) for the Vela programming language. These keywords cannot be used as identifiers (variable names, function names, type names, etc.) as they have special meaning in the language syntax.

**IMPORTANTE:** Vela es un lenguaje **funcional puro** con reactividad integrada. **NO incluye loops imperativos** (`for`, `while`, `loop`) ni valores nulos (`null`, `undefined`, `nil`). La mutabilidad se logra SOLO mediante el keyword `state` (reactivo).

## Summary Statistics

| Category | Count | Examples |
|----------|-------|----------|
| **Control Flow (Functional)** | 3 | `if`, `else`, `match` (NO loops) |
| **Variables** | 1 | `state` (único keyword mutable) |
| **Declarations** | 6 | `fn`, `struct`, `enum`, `type`, `class`, `interface` |
| **Types Primitivos** | 6 | `Number`, `Float`, `String`, `Bool`, `void`, `never` |
| **Valores Booleanos** | 3 | `true`, `false`, `None` (NO null) |
| **Error Handling** | 4 | `try`, `catch`, `throw`, `finally` |
| **Async Programming** | 3 | `async`, `await`, `yield` |
| **Module System** | 4 | `import`, `show`, `hide`, `as` (NO export) |
| **Visibility** | 3 | `public`, `private`, `protected` |
| **OOP** | 7 | `abstract`, `extends`, `implements`, `override`, `overload`, `this`, `super`, `constructor` |
| **Reactive System** | 4 | `computed`, `memo`, `effect`, `watch` |
| **Lifecycle** | 5 | `mount`, `update`, `destroy`, `beforeUpdate`, `afterUpdate` |
| **UI Widgets** | 4 | `StatefulWidget`, `StatelessWidget`, `component`, `widget` |
| **Architecture (DDD)** | 8 | `service`, `repository`, `controller`, `usecase`, `entity`, `dto`, `valueObject`, `model` |
| **Design Patterns** | 7 | `factory`, `builder`, `strategy`, `observer`, `singleton`, `adapter`, `decorator` |
| **Web/API** | 5 | `guard`, `middleware`, `interceptor`, `validator`, `pipe` |
| **Utilities** | 6 | `task`, `helper`, `mapper`, `serializer`, `provider`, `store` |
| **Return** | 1 | `return` |
| **TOTAL** | **~100** | |

---

## ❌ Keywords que NO EXISTEN en Vela

**IMPORTANTE:** Los siguientes keywords comúnmente encontrados en otros lenguajes **NO EXISTEN** en Vela:

### Loops Imperativos (PROHIBIDOS)
```
❌ for        - NO EXISTE (usar métodos funcionales: .map(), .filter(), .forEach())
❌ while      - NO EXISTE (usar recursión o métodos funcionales)
❌ loop       - NO EXISTE (usar recursión tail-call optimizada)
❌ break      - NO EXISTE (no hay loops)
❌ continue   - NO EXISTE (no hay loops)
❌ do         - NO EXISTE (no hay do-while)
```

**Razón:** Vela es funcional puro. Se usan métodos funcionales en su lugar.

### Mutabilidad por Defecto (PROHIBIDOS)
```
❌ let        - NO EXISTE (variables son inmutables por defecto)
❌ const      - NO EXISTE (inmutabilidad es por defecto, NO necesita keyword)
❌ var        - NO EXISTE (jamás)
❌ mut        - NO EXISTE (usar `state` para mutabilidad reactiva)
```

**Razón:** Inmutabilidad por defecto. Solo `state` permite mutabilidad (reactiva).

### Valores Nulos (PROHIBIDOS)
```
❌ null       - NO EXISTE (usar `None` en `Option<T>`)
❌ undefined  - NO EXISTE (usar `Option<T>`)
❌ nil        - NO EXISTE (usar `None`)
```

**Razón:** Vela usa `Option<T>` con `Some(value)` y `None` para seguridad de tipos.

### Exports Explícitos (PROHIBIDO)
```
❌ export     - NO EXISTE (usar modificador `public` en lugar)
❌ module     - NO EXISTE (usar estructura de carpetas)
```

**Razón:** Consistencia con modificadores de acceso (`public`, `private`, `protected`).

### Otros (PROHIBIDOS)
```
❌ switch     - NO EXISTE (usar `match` con pattern matching)
❌ case       - NO EXISTE (usar `match`)
❌ default    - NO EXISTE (usar `_` en match)
❌ goto       - NO EXISTE (jamás)
❌ with       - NO EXISTE
❌ in         - NO EXISTE como keyword standalone
❌ pub        - NO EXISTE (usar `public` completo)
❌ unsafe     - NO EXISTE (Vela es memory-safe siempre)
❌ extern     - NO EXISTE en Phase 0
❌ static     - NO EXISTE (usar singleton pattern)
❌ crate      - NO EXISTE (no es Rust)
❌ self       - NO EXISTE (usar `this`)
❌ Self       - NO EXISTE (usar nombre de clase)
❌ impl       - NO EXISTE (usar `class` o `implements`)
❌ trait      - NO EXISTE (usar `interface`)
```

---

## ✅ Complete Keyword List (Alphabetical)

Total: **~100 keywords**

```
abstract        adapter         afterUpdate     as              async
await           beforeUpdate    Bool            builder         catch
class           component       computed        constructor     controller
decorator       destroy         dto             effect          else
entity          enum            extends         factory         false
finally         Float           fn              guard           helper
hide            if              implements      import          interceptor
interface       mapper          match           memo            middleware
model           mount           never           None            Number
observer        override        overload        pipe            private
protected       provider        public          repository      return
serializer      service         show            singleton       state
StatefulWidget  StatelessWidget store           strategy        String
struct          super           task            this            throw
try             type            update          usecase         validator
valueObject     void            watch           widget          yield
```

---

## Keywords by Category (Detailed)

### 1. Control Flow Keywords (3) - FUNCTIONAL ONLY

| Keyword | Description | Example |
|---------|-------------|---------|
| `if` | Conditional expression (también es expression) | `if x > 0 { "positive" } else { "negative" }` |
| `else` | Alternative branch | `if x > 0 { ... } else { ... }` |
| `match` | Pattern matching exhaustivo | `match value { Some(x) => x, None => 0 }` |

**⚠️ NO HAY LOOPS IMPERATIVOS** - Vela es funcional puro.

**Examples:**
```vela
# if-else como expression
status = if age >= 18 { "adult" } else { "minor" }

# match con pattern matching
match result {
  Ok(value) => print("Success: ${value}")
  Err(error) => print("Error: ${error}")
}

# match con guards
match number {
  n if n < 0 => "negative"
  n if n == 0 => "zero"
  n => "positive"
}

# match con destructuring
match point {
  { x: 0, y: 0 } => "origin"
  { x, y } => "point at (${x}, ${y})"
}

# ❌ PROHIBIDO: loops imperativos
# for i in 0..10 { print(i) }  // ERROR
# while condition { work() }    // ERROR

# ✅ CORRECTO: métodos funcionales
(0..10).forEach(i => print(i))
list.map(x => x * 2).filter(x => x > 5)
```

---

### 2. Variables & Mutability (1) - Immutable by Default

| Keyword | Description | Example |
|---------|-------------|---------|
| `state` | Variable mutable y reactiva (ÚNICA mutabilidad) | `state count: Number = 0` |

**⚠️ Variables son INMUTABLES por defecto (sin keyword).**

**Examples:**
```vela
# ✅ Inmutable por defecto (NO necesita const ni let)
name: String = "Vela"
PI: Float = 3.14159

# ❌ NO se puede mutar inmutable
# name = "Otro"  // ERROR de compilación

# ✅ state para mutabilidad reactiva
state counter: Number = 0
counter = counter + 1  # OK, es mutable y reactivo

# ✅ Shadowing (nueva variable, NO mutación)
x: Number = 5
x: Number = x + 1  # Nueva variable x
```

---

### 3. Declaration Keywords (6)

| Keyword | Description | Example |
|---------|-------------|---------|
| `fn` | Function declaration | `fn add(a: Number, b: Number) -> Number { return a + b }` |
| `struct` | Structure type (record/producto) | `struct Point { x: Number, y: Number }` |
| `enum` | Enumeration (con/sin datos) | `enum Color { Red, Green, Blue, Custom(r, g, b) }` |
| `type` | Type alias o union type | `type UserId = Number` o `type Status = "active" \| "inactive"` |
| `class` | Class declaration (OOP) | `class Person { name: String }` |
| `interface` | Interface/contract | `interface Drawable { fn draw() -> void }` |

**Examples:**
```vela
# Function
fn calculate(a: Number, b: Number) -> Number {
  return a + b
}

# Arrow function
add = (a: Number, b: Number) => a + b

# Struct
struct User {
  id: Number
  name: String
  email: String
}

# Enum
enum Result<T, E> {
  Ok(T)
  Err(E)
}

# Type alias
type UserId = Number

# Union type
type Status = "active" | "inactive" | "pending"

# Class
class Rectangle {
  width: Number
  height: Number
  
  constructor(width: Number, height: Number) {
    this.width = width
    this.height = height
  }
  
  fn area() -> Number {
    return this.width * this.height
  }
}

# Interface
interface Serializable {
  fn toJSON() -> String
}
```

---

### 4. Type Keywords (6)

| Keyword | Description | Example |
|---------|-------------|---------|
| `Number` | Integer (64-bit) | `age: Number = 37` |
| `Float` | Floating point (64-bit) | `price: Float = 19.99` |
| `String` | String type | `name: String = "Vela"` |
| `Bool` | Boolean type | `isActive: Bool = true` |
| `void` | No return value | `fn log() -> void { }` |
| `never` | Never returns | `fn panic() -> never { throw Error() }` |

**Examples:**
```vela
# Primitive types
age: Number = 37
price: Float = 19.99
name: String = "Vela"
isActive: Bool = true

# Function return types
fn greet() -> void {
  print("Hello")
}

fn panic(msg: String) -> never {
  throw Error(msg)
}

# Option<T> (NO null)
user: Option<User> = None
result: Option<Number> = Some(42)
```

---

### 5. Visibility & Modifier Keywords (3)

| Keyword | Description | Example |
|---------|-------------|---------|
| `public` | Public visibility (accesible externamente) | `public fn publicFunction() -> void { }` |
| `private` | Private visibility (solo dentro de clase/módulo) | `private fn helper() -> void { }` |
| `protected` | Protected visibility (clase y subclases) | `protected fn method() -> void { }` |

**⚠️ NO EXISTE `export` - usar `public` en su lugar.**

**Examples:**
```vela
# Public (accesible desde otros módulos)
public class MyClass {
  public name: String
  
  public fn greet() -> void {
    print("Hello")
  }
}

# Private (solo dentro del módulo/clase)
private fn internalHelper() -> void {
  # solo accesible aquí
}

class Person {
  private age: Number  # solo dentro de Person
  
  protected fn validate() -> Bool {
    # accesible en subclases
  }
}
```

**Examples:**
```vela
// Public visibility
pub struct PublicStruct { ... }
pub fn public_function() { ... }

// Mutable
let mut counter = 0;
counter += 1;

// Async
async fn fetch_data() -> Result<Data> {
    let response = http_client.get(url).await?;
    response.json().await
}

// Static
static mut GLOBAL_COUNTER: i32 = 0;

// Unsafe (future feature)
unsafe {
    // Low-level operations
}

// Extern (future feature)
extern "C" {
    fn external_function(x: i32) -> i32;
}
```

---

### 4. Types & Special Values (7)

| Keyword | Description | Example |
|---------|-------------|---------|
| `true` | Boolean true literal | `let valid = true;` |
| `false` | Boolean false literal | `let valid = false;` |
| `null` | Null/undefined value | `let optional = null;` |
| `self` | Current instance (lowercase) | `self.name` |
| `Self` | Current type (capitalized) | `fn new() -> Self { ... }` |
| `super` | Parent module | `super::parent_function();` |
| `crate` | Current crate root | `crate::root_module::function();` |

**Examples:**
```vela
// Booleans
let is_valid = true;
let is_ready = false;

// Null
let maybe_value: i32? = null;

// self (instance)
struct Point {
    x: i32,
    y: i32,
}

impl Point {
    fn distance(&self) -> f64 {
        ((self.x ** 2 + self.y ** 2) as f64).sqrt()
    }
}

// Self (type)
impl Point {
    fn new(x: i32, y: i32) -> Self {
        Self { x, y }
    }
}

// super (parent module)
mod parent {
    pub fn parent_fn() { ... }
    
    mod child {
        fn child_fn() {
            super::parent_fn();  // Call parent module function
        }
    }
}

// crate (root)
crate::utils::helper_function();
```

---

### 5. Error Handling Keywords (3)

| Keyword | Description | Example |
|---------|-------------|---------|
| `try` | Try block (error handling) | `try { ... } catch (e) { ... }` |
| `catch` | Catch exceptions | `try { ... } catch (e) { print(e); }` |
| `throw` | Throw/raise exception | `throw Error("something went wrong");` |

**Examples:**
```vela
// Try-catch
try {
    let file = open_file("data.txt")?;
    process(file);
} catch (e) {
    print("Error: ${e}");
}

// Throw
fn validate(x: i32) {
    if x < 0 {
        throw Error("value must be positive");
    }
}

// ? operator (error propagation)
fn read_config() -> Result<Config> {
    let file = open_file("config.toml")?;  // Returns early on error
    let content = file.read_to_string()?;
    parse_config(content)
}
```

---

### 6. Async Programming Keywords (2)

| Keyword | Description | Example |
|---------|-------------|---------|
| `async` | Async function modifier | `async fn fetch() { ... }` |
| `await` | Await async operation | `let result = async_call().await;` |

**Examples:**
```vela
// Async function
async fn fetch_user(id: UserId) -> Result<User> {
    let response = http_client.get("/users/${id}").await?;
    response.json().await
}

// Await in async context
async fn process() {
    let user = fetch_user(123).await?;
    let profile = fetch_profile(user.id).await?;
    save_data(user, profile).await?;
}

// Parallel async
async fn fetch_all() {
    let (users, posts, comments) = await! [
        fetch_users(),
        fetch_posts(),
        fetch_comments(),
    ];
}
```

---

### 7. Module System Keywords (5)

| Keyword | Description | Example |
|---------|-------------|---------|
| `import` | Import from module | `import { User } from "./models";` |
| `export` | Export from module | `export fn helper() { ... }` |
| `from` | Source module (used with `import`) | `import { x } from "module";` |
| `as` | Rename import/export | `import { User as UserModel } from "models";` |
| `module` | Module declaration | `module utils { ... }` |

**Examples:**
```vela
// Import
import { User, Post } from "./models";
import * as utils from "./utils";
import config from "./config.json";

// Export
export fn helper() { ... }
export struct Data { ... }
export const MAX = 100;

// Rename
import { VeryLongName as Short } from "module";
export { InternalName as PublicName };

// Module
module database {
    pub fn connect() { ... }
    fn internal_query() { ... }
}
```

---

### 8. Domain-Specific Keywords (25)

These keywords provide built-in support for common architectural patterns and domain-driven design.

#### 8.1 UI Components (2)
| Keyword | Description | Example |
|---------|-------------|---------|
| `widget` | UI widget declaration | `widget Button { ... }` |
| `component` | Reusable component | `component NavBar { ... }` |

#### 8.2 Architecture Layers (4)
| Keyword | Description | Example |
|---------|-------------|---------|
| `service` | Business logic service | `service UserService { ... }` |
| `repository` | Data access layer | `repository UserRepository { ... }` |
| `controller` | Request handler | `controller UserController { ... }` |
| `usecase` | Use case / interactor | `usecase CreateUserUseCase { ... }` |

#### 8.3 Domain Models (4)
| Keyword | Description | Example |
|---------|-------------|---------|
| `dto` | Data Transfer Object | `dto UserDTO { ... }` |
| `entity` | Domain entity | `entity User { ... }` |
| `valueObject` | Value object | `valueObject Email { ... }` |
| `model` | Generic model | `model Product { ... }` |

#### 8.4 Design Patterns (7)
| Keyword | Description | Example |
|---------|-------------|---------|
| `factory` | Factory pattern | `factory UserFactory { ... }` |
| `builder` | Builder pattern | `builder QueryBuilder { ... }` |
| `strategy` | Strategy pattern | `strategy PaymentStrategy { ... }` |
| `observer` | Observer pattern | `observer EventObserver { ... }` |
| `singleton` | Singleton pattern | `singleton Database { ... }` |
| `adapter` | Adapter pattern | `adapter LegacyAdapter { ... }` |
| `decorator` | Decorator pattern | `decorator LoggingDecorator { ... }` |

#### 8.5 Web/API (4)
| Keyword | Description | Example |
|---------|-------------|---------|
| `guard` | Route guard | `guard AuthGuard { ... }` |
| `middleware` | HTTP middleware | `middleware Logger { ... }` |
| `interceptor` | Request/response interceptor | `interceptor AuthInterceptor { ... }` |
| `validator` | Input validator | `validator EmailValidator { ... }` |

#### 8.6 Utilities (4)
| Keyword | Description | Example |
|---------|-------------|---------|
| `pipe` | Data transformation pipeline | `pipe TransformPipe { ... }` |
| `task` | Async task/job | `task EmailTask { ... }` |
| `helper` | Helper utility | `helper DateHelper { ... }` |
| `mapper` | Object mapper | `mapper UserMapper { ... }` |
| `serializer` | Data serializer | `serializer JsonSerializer { ... }` |

**Examples:**
```vela
// Widget
widget Button {
    props: {
        text: string,
        onClick: fn(),
    }
    
    render() {
        <button onclick={props.onClick}>{props.text}</button>
    }
}

// Service
service UserService {
    repository: UserRepository,
    
    fn create_user(&self, data: CreateUserDTO) -> Result<User> {
        let user = User::new(data);
        self.repository.save(user)
    }
}

// Repository
repository UserRepository {
    fn find_by_id(&self, id: UserId) -> Option<User> {
        // Database query
    }
    
    fn save(&mut self, user: User) -> Result<User> {
        // Insert/update
    }
}

// DTO
dto CreateUserDTO {
    name: string,
    email: string,
    password: string,
}

// Entity
entity User {
    id: UserId,
    name: string,
    email: Email,  // ValueObject
    created_at: DateTime,
}

// Factory
factory UserFactory {
    fn create_from_dto(dto: CreateUserDTO) -> User {
        User {
            id: generate_id(),
            name: dto.name,
            email: Email::new(dto.email),
            created_at: now(),
        }
    }
}

// Middleware
middleware Logger {
    fn handle(&self, req: Request, next: fn(Request) -> Response) -> Response {
        log("Request: ${req.path}");
        let response = next(req);
        log("Response: ${response.status}");
        response
    }
}

// Guard
guard AuthGuard {
    fn can_activate(&self, context: Context) -> bool {
        context.user?.is_authenticated() ?? false
    }
}
```

---

### 9. Reactive System Keywords (8)

| Keyword | Description | Example |
|---------|-------------|---------|
| `Signal` | Reactive signal | `let count = Signal(0);` |
| `Computed` | Computed value | `let double = Computed(() => count() * 2);` |
| `Effect` | Side effect | `Effect(() => { print(count()); });` |
| `Watch` | Watch for changes | `Watch(count, (newVal) => { ... });` |
| `store` | Global state store | `store AppStore { ... }` |
| `dispatch` | Dispatch action | `dispatch(INCREMENT);` |
| `provide` | Provide dependency | `provide(UserService, new UserService());` |
| `inject` | Inject dependency | `let service = inject(UserService);` |

**Examples:**
```vela
// Signals
let count = Signal(0);
let name = Signal("Alice");

// Computed
let doubled = Computed(() => count() * 2);
let greeting = Computed(() => "Hello, ${name()}!");

// Effect (runs when dependencies change)
Effect(() => {
    print("Count is now: ${count()}");
});

// Watch (more control than Effect)
Watch(count, (newValue, oldValue) => {
    print("Changed from ${oldValue} to ${newValue}");
});

// Store
store AppStore {
    state: {
        count: 0,
        users: [],
    }
    
    actions: {
        increment() {
            this.state.count += 1;
        }
        
        add_user(user: User) {
            this.state.users.push(user);
        }
    }
}

// Dispatch
dispatch({ type: "INCREMENT" });
dispatch({ type: "ADD_USER", payload: user });

// Dependency Injection
@injectable
service UserService {
    repository: UserRepository = inject(UserRepository),
}

provide(UserRepository, new UserRepository());
let service = inject(UserService);
```

---

### 10. Reserved Keywords (Future Use) (5)

These keywords are reserved for potential future language features and cannot be used as identifiers.

| Keyword | Description | Potential Use |
|---------|-------------|---------------|
| `macro` | Macro system | Compile-time code generation |
| `defer` | Deferred execution | Cleanup code (like Go's defer) |
| `go` | Goroutine-style concurrency | Lightweight threads |
| `chan` | Channel communication | CSP-style message passing |
| `select` | Channel select | Choose from multiple channels |

**Potential Future Syntax:**
```vela
// Macro (hypothetical)
macro debug(expr) {
    print("Debug: ${expr} = ${eval(expr)}");
}

// Defer (hypothetical)
fn process_file() {
    let file = open("data.txt");
    defer file.close();  // Executes when function returns
    
    // Work with file...
}

// Channels (hypothetical)
let ch = chan<i32>();
go {
    ch.send(42);
}
let value = ch.receive();

// Select (hypothetical)
select {
    case msg = ch1.receive() => {
        print("Received from ch1: ${msg}");
    }
    case ch2.send(value) => {
        print("Sent to ch2");
    }
    default => {
        print("No channel ready");
    }
}
```

---

## Contextual Keywords

Some identifiers are **contextual keywords**: they have special meaning only in specific contexts and can be used as regular identifiers elsewhere.

| Keyword | Context | Can be identifier? |
|---------|---------|-------------------|
| `as` | Import/export, type casting | ❌ No (always reserved) |
| `in` | For loops | ❌ No (always reserved) |
| `of` | Iteration (optional syntax) | ✅ Yes (but rare) |
| `ref` | Pattern matching | ✅ Yes (outside patterns) |
| `typeof` | Type queries | ✅ Yes (outside type context) |

**Examples:**
```vela
// 'as' - always reserved
import { User as UserModel } from "models";
let x = value as i64;

// 'in' - always reserved
for item in list { ... }

// 'ref' - contextual
match value {
    ref x => { /* x is a reference */ }
}
let ref = 10;  // OK: 'ref' as variable name

// 'typeof' - contextual
type MyType = typeof(some_value);
let typeof = "string";  // OK: 'typeof' as variable name
```

---

## Conflict Prevention

### Cannot be used as:
- ❌ Variable names: `let if = 10;` → **ERROR**
- ❌ Function names: `fn while() { ... }` → **ERROR**
- ❌ Type names: `struct match { ... }` → **ERROR**
- ❌ Field names: `struct User { let: string }` → **ERROR**
- ❌ Module names: `module fn { ... }` → **ERROR**

### Can be used as:
- ✅ String literals: `let keyword = "if";` → **OK**
- ✅ In comments: `// This is an if statement` → **OK**
- ✅ Raw identifiers (future): `let r#type = 10;` → **OK** (like Rust)

---

## Keyword Grouping by First Letter

| Letter | Keywords |
|--------|----------|
| **A** | `abstract`, `actor`, `adapter`, `as`, `async`, `await` |
| **B** | `boolean`, `break`, `builder` |
| **C** | `catch`, `chan`, `component`, `Computed`, `const`, `continue`, `controller`, `crate` |
| **D** | `decorator`, `defer`, `dispatch`, `dto` |
| **E** | `Effect`, `else`, `entity`, `enum`, `export`, `extern` |
| **F** | `factory`, `false`, `fn`, `for`, `from` |
| **G** | `go`, `guard` |
| **H** | `helper` |
| **I** | `if`, `impl`, `import`, `in`, `inject`, `interceptor`, `interface` |
| **L** | `let`, `loop` |
| **M** | `macro`, `mapper`, `match`, `middleware`, `model`, `module`, `mut` |
| **N** | `new`, `null`, `number` |
| **O** | `observer`, `of` |
| **P** | `pipe`, `provide`, `provider`, `pub` |
| **R** | `ref`, `repository`, `return` |
| **S** | `select`, `self`, `Self`, `serializer`, `service`, `Signal`, `singleton`, `static`, `store`, `strategy`, `string`, `struct`, `super` |
| **T** | `task`, `throw`, `trait`, `true`, `try`, `type`, `typeof` |
| **U** | `unsafe`, `usecase` |
| **V** | `validator`, `valueObject` |
| **W** | `watch`, `Watch`, `while`, `widget` |
| **Y** | `yield` |

---

## Design Rationale

### Why so many domain-specific keywords?

**Pros:**
- ✅ **Clarity:** `service UserService` is clearer than `struct UserService` with comments
- ✅ **Enforces architecture:** Prevents mixing concerns
- ✅ **IDE support:** Better autocomplete and navigation
- ✅ **Code generation:** Can generate boilerplate based on keyword

**Cons:**
- ⚠️ More keywords to learn
- ⚠️ Less flexibility in naming

**Decision:** Vela prioritizes **clarity and architecture enforcement** over minimalism.

### Why separate `Signal` vs `store`?

- `Signal`: Fine-grained reactivity (single value)
- `store`: Global state management (multiple values + actions)

Different use cases warrant different keywords.

### Why reserve keywords for future features?

Prevents breaking changes when features are added. Better to reserve early than break existing code later.

---

## Comparison with Other Languages

| Language | Total Keywords | Notes |
|----------|----------------|-------|
| Vela | 80 | Domain-specific + reactive |
| Rust | 53 | Systems programming focus |
| Python | 35 | Minimal, dynamic |
| JavaScript | 63 (ES2022) | Includes contextual |
| Java | 50 | OOP-focused |
| C++ | 95 | Large, complex |
| Go | 25 | Minimalist philosophy |
| TypeScript | 65+ | JavaScript + types |

Vela has **more keywords** than most languages due to domain-specific and reactive system support, but each keyword serves a clear purpose.

---

## Future Considerations

### Potential Additions
- `macro` - Macro system
- `defer` - Deferred execution
- `go` / `chan` / `select` - CSP-style concurrency
- `union` - Tagged unions (distinct from enum?)
- `interface` - Separate from trait?

### Deprecated/Removed
None yet (Phase 0)

---

**TASK:** TASK-003  
**Historia:** VELA-566 (US-01)  
**Sprint:** Sprint 4 (Phase 0)  
**Status:** Completed ✅  
**Date:** 2025-11-30
