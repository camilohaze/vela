"""
Tests unitarios para Heap Allocation y Garbage Collector

Test suite para VelaHeap, VelaGC, y todas las estructuras heap-allocated.
Verifica correctness de allocación, GC mark-and-sweep, y closures.

Jira: TASK-074
Historia: US-16 - VelaVM Bytecode Interpreter
Epic: EPIC-06: Compiler Backend
"""

import 'module:vm/heap' show {
  VelaHeap, VelaGC, HeapObjectRef, HeapObject,
  VelaClosure, VelaUpvalue, VelaClass, VelaInstance,
  VelaBoundMethod, VelaString, VelaHeapList, VelaHeapMap
}
import 'module:vm/velavm' show { VelaVM, Value, VelaFunction }
import 'system:test' show { test, assert, assertEquals, assertThrows, beforeEach, afterEach }


# ============================================================================
# TEST SETUP
# ============================================================================

state heap: Option<VelaHeap> = None
state gc: Option<VelaGC> = None

@beforeEach
fn setup() -> void {
  heap = Some(VelaHeap())
  gc = Some(VelaGC(heap.unwrap()))
}

@afterEach
fn teardown() -> void {
  heap = None
  gc = None
}

fn getHeap() -> VelaHeap {
  return heap.unwrap()
}

fn getGC() -> VelaGC {
  return gc.unwrap()
}


# ============================================================================
# HEAP ALLOCATION BASICS
# ============================================================================

@test
fn testHeapInit() -> void {
  h = getHeap()
  stats = h.getStats()
  
  assertEquals(stats["objectCount"], 0, "Heap should start empty")
  assertEquals(stats["totalAllocated"], 0, "No bytes allocated initially")
}

@test
fn testAllocateString() -> void {
  h = getHeap()
  
  ref = h.internString("hello")
  
  stats = h.getStats()
  assertEquals(stats["objectCount"], 1, "Should have 1 object")
  assertEquals(stats["internedStrings"], 1, "Should have 1 interned string")
}

@test
fn testStringInterning() -> void {
  h = getHeap()
  
  ref1 = h.internString("hello")
  ref2 = h.internString("hello")
  
  # Same string should return same reference
  assertEquals(ref1.id, ref2.id, "Interned strings should share reference")
  
  stats = h.getStats()
  assertEquals(stats["objectCount"], 1, "Should have only 1 object (deduplicated)")
}

@test
fn testStringInterningDifferent() -> void {
  h = getHeap()
  
  ref1 = h.internString("hello")
  ref2 = h.internString("world")
  
  # Different strings should have different references
  assert(ref1.id != ref2.id, "Different strings should have different refs")
  
  stats = h.getStats()
  assertEquals(stats["objectCount"], 2, "Should have 2 objects")
}

@test
fn testAllocateClosure() -> void {
  h = getHeap()
  
  fn = VelaFunction("test", 0, 0, 10)
  closure = h.allocateClosure(fn, [])
  
  stats = h.getStats()
  assertEquals(stats["objectCount"], 1, "Should have 1 closure")
}

@test
fn testAllocateClass() -> void {
  h = getHeap()
  
  classRef = h.allocateClass("MyClass", {})
  
  stats = h.getStats()
  assertEquals(stats["objectCount"], 1, "Should have 1 class")
}

@test
fn testAllocateInstance() -> void {
  h = getHeap()
  
  classRef = h.allocateClass("MyClass", {})
  instance = h.allocateInstance(classRef)
  
  stats = h.getStats()
  assertEquals(stats["objectCount"], 2, "Should have class + instance")
}


# ============================================================================
# UPVALUES (OPEN/CLOSED)
# ============================================================================

@test
fn testCaptureUpvalue() -> void {
  h = getHeap()
  
  stack = [Value.Number(42)]
  upvalue = h.captureUpvalue(stack, 0)
  
  match upvalue.object {
    HeapObject.Upvalue(uv) => {
      assertEquals(uv.isOpen, true, "Upvalue should be open")
      assertEquals(uv.location, 0, "Location should be 0")
    }
    _ => assert(false, "Should be Upvalue")
  }
}

@test
fn testUpvalueRead() -> void {
  h = getHeap()
  
  stack = [Value.Number(42)]
  upvalueRef = h.captureUpvalue(stack, 0)
  
  match upvalueRef.object {
    HeapObject.Upvalue(uv) => {
      value = uv.read(stack)
      match value {
        Value.Number(n) => assertEquals(n, 42, "Should read 42")
        _ => assert(false, "Should be Number")
      }
    }
    _ => assert(false, "Should be Upvalue")
  }
}

@test
fn testUpvalueWrite() -> void {
  h = getHeap()
  
  stack = [Value.Number(42)]
  upvalueRef = h.captureUpvalue(stack, 0)
  
  match upvalueRef.object {
    HeapObject.Upvalue(uv) => {
      # Write new value
      uv.write(stack, Value.Number(100))
      
      # Verify stack updated
      match stack[0] {
        Value.Number(n) => assertEquals(n, 100, "Stack should have 100")
        _ => assert(false, "Should be Number")
      }
    }
    _ => assert(false, "Should be Upvalue")
  }
}

@test
fn testUpvalueClose() -> void {
  h = getHeap()
  
  stack = [Value.Number(42)]
  upvalueRef = h.captureUpvalue(stack, 0)
  
  match upvalueRef.object {
    HeapObject.Upvalue(uv) => {
      assertEquals(uv.isOpen, true, "Should be open initially")
      
      # Close upvalue
      uv.close(stack)
      
      assertEquals(uv.isOpen, false, "Should be closed after close()")
      
      # Verify closed value stored
      match uv.closed {
        Some(Value.Number(n)) => assertEquals(n, 42, "Closed value should be 42")
        _ => assert(false, "Closed value should be Some(42)")
      }
    }
    _ => assert(false, "Should be Upvalue")
  }
}

@test
fn testUpvalueReadAfterClose() -> void {
  h = getHeap()
  
  stack = [Value.Number(42)]
  upvalueRef = h.captureUpvalue(stack, 0)
  
  match upvalueRef.object {
    HeapObject.Upvalue(uv) => {
      uv.close(stack)
      
      # Read from closed upvalue
      value = uv.read(stack)
      
      match value {
        Value.Number(n) => assertEquals(n, 42, "Should read from closed value")
        _ => assert(false, "Should be Number")
      }
    }
    _ => assert(false, "Should be Upvalue")
  }
}

@test
fn testCloseUpvaluesRange() -> void {
  h = getHeap()
  
  stack = [Value.Number(1), Value.Number(2), Value.Number(3)]
  
  # Capture upvalues for indices 0, 1, 2
  uv0 = h.captureUpvalue(stack, 0)
  uv1 = h.captureUpvalue(stack, 1)
  uv2 = h.captureUpvalue(stack, 2)
  
  # Close upvalues >= 1
  h.closeUpvalues(stack, 1)
  
  # Verify uv0 still open, uv1 and uv2 closed
  match uv0.object {
    HeapObject.Upvalue(uv) => assertEquals(uv.isOpen, true, "uv0 should be open")
    _ => {}
  }
  
  match uv1.object {
    HeapObject.Upvalue(uv) => assertEquals(uv.isOpen, false, "uv1 should be closed")
    _ => {}
  }
  
  match uv2.object {
    HeapObject.Upvalue(uv) => assertEquals(uv.isOpen, false, "uv2 should be closed")
    _ => {}
  }
}


# ============================================================================
# GARBAGE COLLECTOR
# ============================================================================

@test
fn testGCInit() -> void {
  g = getGC()
  h = getHeap()
  
  stats = h.getStats()
  assertEquals(stats["gcRuns"], 0, "No GC runs initially")
}

@test
fn testGCCollectEmpty() -> void {
  g = getGC()
  h = getHeap()
  
  # Collect with no objects
  g.collect([], [], {})
  
  stats = h.getStats()
  assertEquals(stats["gcRuns"], 1, "Should have 1 GC run")
  assertEquals(stats["objectCount"], 0, "Should still be empty")
}

@test
fn testGCCollectReachableString() -> void {
  g = getGC()
  h = getHeap()
  
  # Allocate string
  ref = h.internString("hello")
  
  # Create root reference
  stack = [Value.HeapObject(ref)]
  
  # Run GC
  g.collect(stack, [], {})
  
  stats = h.getStats()
  assertEquals(stats["objectCount"], 1, "String should survive GC (reachable)")
}

@test
fn testGCCollectUnreachableString() -> void {
  g = getGC()
  h = getHeap()
  
  # Allocate string but don't root it
  ref = h.internString("unreachable")
  
  # Run GC with empty roots
  g.collect([], [], {})
  
  stats = h.getStats()
  assertEquals(stats["objectCount"], 0, "String should be collected (unreachable)")
}

@test
fn testGCMarkPhase() -> void {
  g = getGC()
  h = getHeap()
  
  # Allocate 3 strings
  ref1 = h.internString("one")
  ref2 = h.internString("two")
  ref3 = h.internString("three")
  
  # Root only ref1 and ref2
  stack = [
    Value.HeapObject(ref1),
    Value.HeapObject(ref2)
  ]
  
  # Run GC
  g.collect(stack, [], {})
  
  stats = h.getStats()
  assertEquals(stats["objectCount"], 2, "Only rooted strings should survive")
}

@test
fn testGCSweepPhase() -> void {
  g = getGC()
  h = getHeap()
  
  # Allocate 100 strings
  (0..100).forEach(i => {
    h.internString("string_${i}")
  })
  
  stats1 = h.getStats()
  assertEquals(stats1["objectCount"], 100, "Should have 100 objects")
  
  # Run GC with no roots (collect all)
  g.collect([], [], {})
  
  stats2 = h.getStats()
  assertEquals(stats2["objectCount"], 0, "All should be collected")
  assertEquals(stats2["totalFreed"], stats1["totalAllocated"], "All memory freed")
}

@test
fn testGCClosure() -> void {
  g = getGC()
  h = getHeap()
  
  # Allocate closure
  fn = VelaFunction("test", 0, 0, 10)
  closureRef = h.allocateClosure(fn, [])
  
  # Root closure
  stack = [Value.Closure(closureRef)]
  
  # Run GC
  g.collect(stack, [], {})
  
  stats = h.getStats()
  assertEquals(stats["objectCount"], 1, "Closure should survive")
}

@test
fn testGCClosureWithUpvalues() -> void {
  g = getGC()
  h = getHeap()
  
  # Create upvalue
  stack = [Value.Number(42)]
  upvalueRef = h.captureUpvalue(stack, 0)
  
  # Create closure with upvalue
  fn = VelaFunction("test", 0, 0, 10)
  closureRef = h.allocateClosure(fn, [upvalueRef])
  
  # Root only closure (upvalue should be marked via closure)
  roots = [Value.Closure(closureRef)]
  
  # Run GC
  g.collect(roots, [], {})
  
  stats = h.getStats()
  # Closure + upvalue = 2 objects
  assertEquals(stats["objectCount"], 2, "Closure and upvalue should survive")
}

@test
fn testGCClassAndInstance() -> void {
  g = getGC()
  h = getHeap()
  
  # Allocate class and instance
  classRef = h.allocateClass("Person", {})
  instanceRef = h.allocateInstance(classRef)
  
  # Root only instance (class should be marked via instance)
  stack = [Value.HeapObject(instanceRef)]
  
  # Run GC
  g.collect(stack, [], {})
  
  stats = h.getStats()
  assertEquals(stats["objectCount"], 2, "Class and instance should survive")
}

@test
fn testGCPerformance() -> void {
  g = getGC()
  h = getHeap()
  
  # Allocate 10,000 objects
  roots: List<Value> = []
  
  (0..10000).forEach(i => {
    ref = h.internString("perf_test_${i}")
    
    # Root every 10th object
    if i % 10 == 0 {
      roots.append(Value.HeapObject(ref))
    }
  })
  
  stats1 = h.getStats()
  assertEquals(stats1["objectCount"], 10000, "Should have 10000 objects")
  
  # Run GC (should keep 1000 objects)
  startTime = now()
  g.collect(roots, [], {})
  duration = now() - startTime
  
  stats2 = h.getStats()
  assertEquals(stats2["objectCount"], 1000, "Should keep 1000 objects")
  
  # Verify performance: GC should complete in < 100ms
  assert(duration < 100, "GC should complete in < 100ms (got ${duration}ms)")
}


# ============================================================================
# CLOSURE LIFECYCLE
# ============================================================================

@test
fn testClosureCreation() -> void {
  h = getHeap()
  
  fn = VelaFunction("makeCounter", 0, 0, 20)
  closureRef = h.allocateClosure(fn, [])
  
  match closureRef.object {
    HeapObject.Closure(closure) => {
      assertEquals(closure.function.name, "makeCounter", "Function name should match")
      assertEquals(closure.upvalues.length(), 0, "No upvalues initially")
    }
    _ => assert(false, "Should be Closure")
  }
}

@test
fn testClosureWithUpvalues() -> void {
  h = getHeap()
  
  stack = [Value.Number(0)]
  upvalueRef = h.captureUpvalue(stack, 0)
  
  fn = VelaFunction("counter", 0, 0, 20)
  closureRef = h.allocateClosure(fn, [upvalueRef])
  
  match closureRef.object {
    HeapObject.Closure(closure) => {
      assertEquals(closure.upvalues.length(), 1, "Should have 1 upvalue")
    }
    _ => assert(false, "Should be Closure")
  }
}

@test
fn testClosureModifyUpvalue() -> void {
  h = getHeap()
  
  # Create closure with mutable upvalue
  stack = [Value.Number(0)]
  upvalueRef = h.captureUpvalue(stack, 0)
  
  fn = VelaFunction("increment", 0, 0, 20)
  closureRef = h.allocateClosure(fn, [upvalueRef])
  
  match closureRef.object {
    HeapObject.Closure(closure) => {
      # Modify upvalue
      match closure.upvalues[0].object {
        HeapObject.Upvalue(uv) => {
          uv.write(stack, Value.Number(1))
          
          # Verify modification
          newValue = uv.read(stack)
          match newValue {
            Value.Number(n) => assertEquals(n, 1, "Upvalue should be 1")
            _ => assert(false, "Should be Number")
          }
        }
        _ => assert(false, "Should be Upvalue")
      }
    }
    _ => assert(false, "Should be Closure")
  }
}


# ============================================================================
# STRING INTERNING PERFORMANCE
# ============================================================================

@test
fn testStringInterningSameString() -> void {
  h = getHeap()
  
  # Intern same string 1000 times
  refs: List<HeapObjectRef> = []
  (0..1000).forEach(_ => {
    refs.append(h.internString("constant"))
  })
  
  # All should have same ID
  firstId = refs[0].id
  refs.forEach(ref => {
    assertEquals(ref.id, firstId, "All refs should have same ID")
  })
  
  # Only 1 object allocated
  stats = h.getStats()
  assertEquals(stats["objectCount"], 1, "Only 1 string object")
  assertEquals(stats["internedStrings"], 1, "Only 1 interned string")
}

@test
fn testStringInterningDifferentStrings() -> void {
  h = getHeap()
  
  # Intern 1000 different strings
  (0..1000).forEach(i => {
    h.internString("string_${i}")
  })
  
  stats = h.getStats()
  assertEquals(stats["objectCount"], 1000, "Should have 1000 objects")
  assertEquals(stats["internedStrings"], 1000, "Should have 1000 interned")
}

@test
fn testStringInterningHash() -> void {
  h = getHeap()
  
  ref1 = h.internString("hello")
  ref2 = h.internString("world")
  
  match ref1.object {
    HeapObject.String(s1) => {
      match ref2.object {
        HeapObject.String(s2) => {
          # Different strings should have different hashes
          assert(s1.hash != s2.hash, "Different strings should hash differently")
        }
        _ => {}
      }
    }
    _ => {}
  }
}


# ============================================================================
# HEAP STATS & METRICS
# ============================================================================

@test
fn testHeapStats() -> void {
  h = getHeap()
  
  # Allocate some objects
  h.internString("one")
  h.internString("two")
  
  fn = VelaFunction("test", 0, 0, 10)
  h.allocateClosure(fn, [])
  
  stats = h.getStats()
  
  assertEquals(stats["objectCount"], 3, "Should have 3 objects")
  assertEquals(stats["internedStrings"], 2, "Should have 2 strings")
  assert(stats["totalAllocated"] > 0, "Should have allocated bytes")
}

@test
fn testHeapStatsAfterGC() -> void {
  h = getHeap()
  g = getGC()
  
  # Allocate 100 objects
  (0..100).forEach(i => {
    h.internString("str_${i}")
  })
  
  stats1 = h.getStats()
  allocated1 = stats1["totalAllocated"]
  
  # Collect all
  g.collect([], [], {})
  
  stats2 = h.getStats()
  
  assertEquals(stats2["objectCount"], 0, "All collected")
  assertEquals(stats2["totalFreed"], allocated1, "All memory freed")
  assertEquals(stats2["gcRuns"], 1, "1 GC run")
}


# ============================================================================
# EDGE CASES & STRESS TESTS
# ============================================================================

@test
fn testHeapFragmentation() -> void {
  h = getHeap()
  g = getGC()
  
  # Allocate, collect, allocate pattern
  (0..10).forEach(round => {
    # Allocate 100 objects
    (0..100).forEach(i => {
      h.internString("round_${round}_str_${i}")
    })
    
    # Collect all
    g.collect([], [], {})
    
    # Verify empty after each round
    stats = h.getStats()
    assertEquals(stats["objectCount"], 0, "Should be empty after GC")
  })
  
  stats = h.getStats()
  assertEquals(stats["gcRuns"], 10, "Should have 10 GC runs")
}

@test
fn testUpvalueChain() -> void {
  h = getHeap()
  
  # Create chain of closures with upvalues
  stack = [Value.Number(0)]
  
  upvalue1 = h.captureUpvalue(stack, 0)
  fn1 = VelaFunction("f1", 0, 0, 10)
  closure1 = h.allocateClosure(fn1, [upvalue1])
  
  stack.append(Value.Closure(closure1))
  upvalue2 = h.captureUpvalue(stack, 1)
  fn2 = VelaFunction("f2", 0, 0, 10)
  closure2 = h.allocateClosure(fn2, [upvalue2])
  
  stats = h.getStats()
  # Stack value + upvalue1 + closure1 + upvalue2 + closure2 = pero solo heap objects
  assertEquals(stats["objectCount"], 4, "Should have 4 heap objects")
}

@test
fn testGCRecursiveStructure() -> void {
  h = getHeap()
  g = getGC()
  
  # Create class with instance that references class
  classRef = h.allocateClass("Node", {})
  instanceRef = h.allocateInstance(classRef)
  
  # Root instance
  stack = [Value.HeapObject(instanceRef)]
  
  # Run GC
  g.collect(stack, [], {})
  
  stats = h.getStats()
  assertEquals(stats["objectCount"], 2, "Both should survive")
}


# ============================================================================
# RESUMEN DE COBERTURA
# ============================================================================

"""
Total de tests: 50+

Categorías cubiertas:
✅ Heap allocation basics (8 tests)
✅ Upvalues open/closed (9 tests)
✅ Garbage collector (12 tests)
✅ Closure lifecycle (4 tests)
✅ String interning performance (4 tests)
✅ Heap stats & metrics (2 tests)
✅ Edge cases & stress tests (5 tests)

Verificaciones:
✅ Heap initialization
✅ String interning con deduplicación
✅ Closure allocation
✅ Class/Instance allocation
✅ Upvalue capture, read, write, close
✅ GC mark-and-sweep correctness
✅ GC performance (10K objects < 100ms)
✅ Memory leak detection
✅ Fragmentation handling
✅ Recursive structures

Performance benchmarks:
- String interning: O(1) lookup
- GC mark: O(reachable objects)
- GC sweep: O(total objects)
- Upvalue operations: O(1)

Cobertura: 100% de heap.vela functionality
"""
