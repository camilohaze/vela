"""
Tests de integración para sistema completo de navegación

Jira: VELA-585 (Sistema de navegación y routing)
Subtask: TASK-068 (Tests de navegación)
Fecha: 2025-12-06

Cobertura:
- Multi-step navigation flows (Home → Users → Detail → Settings → Back)
- Deep linking con parámetros y query strings
- Route guards en acción (autenticación, autorización)
- 404 handling y redirecciones
- State persistence y restoration
- Concurrent navigation (race conditions)
- Memory leaks detection
- Browser history integration
- Named routes flows completos
- Transition testing (diferentes tipos)
"""

import 'system:ui' show { Widget, BuildContext, Container, Text }
import 'system:reactive' show { signal }
import '../../../../core/navigation/router.vela' show {
    Router,
    RouteDefinition,
    RouteGuard,
    createRouter,
    route
}
import '../../../../core/navigation/navigator.vela' show {
    Navigator,
    RouteEntry,
    NavigationResult,
    NavigationResultType,
    TransitionType,
    TransitionConfig,
    createNavigator
}


"""
═══════════════════════════════════════════════════════════════════════════
FIXTURES Y HELPERS
═══════════════════════════════════════════════════════════════════════════
"""

# Mock de widgets para testing
class HomeWidget extends Widget {
    fn build(ctx: BuildContext) -> Widget {
        return Container(child: Text("Home"))
    }
}

class UsersListWidget extends Widget {
    fn build(ctx: BuildContext) -> Widget {
        return Container(child: Text("Users List"))
    }
}

class UserDetailWidget extends Widget {
    userId: String
    
    constructor(userId: String) {
        this.userId = userId
    }
    
    fn build(ctx: BuildContext) -> Widget {
        return Container(child: Text("User ${this.userId}"))
    }
}

class SettingsWidget extends Widget {
    fn build(ctx: BuildContext) -> Widget {
        return Container(child: Text("Settings"))
    }
}

class LoginWidget extends Widget {
    fn build(ctx: BuildContext) -> Widget {
        return Container(child: Text("Login"))
    }
}

class NotFoundWidget extends Widget {
    fn build(ctx: BuildContext) -> Widget {
        return Container(child: Text("404 Not Found"))
    }
}

class AdminWidget extends Widget {
    fn build(ctx: BuildContext) -> Widget {
        return Container(child: Text("Admin Panel"))
    }
}

class PostDetailWidget extends Widget {
    userId: String
    postId: String
    
    constructor(userId: String, postId: String) {
        this.userId = userId
        this.postId = postId
    }
    
    fn build(ctx: BuildContext) -> Widget {
        return Container(child: Text("Post ${this.postId} by User ${this.userId}"))
    }
}

# Mock de autenticación
class AuthService {
    state isAuthenticated: Bool = false
    state isAdmin: Bool = false
    
    fn login() -> void {
        this.isAuthenticated = true
    }
    
    fn loginAsAdmin() -> void {
        this.isAuthenticated = true
        this.isAdmin = true
    }
    
    fn logout() -> void {
        this.isAuthenticated = false
        this.isAdmin = false
    }
}

# Guard de autenticación
class AuthGuard implements RouteGuard {
    authService: AuthService
    
    constructor(authService: AuthService) {
        this.authService = authService
    }
    
    fn canActivate(context: BuildContext, params: Map<String, String>) -> Bool {
        return this.authService.isAuthenticated
    }
}

# Guard de admin
class AdminGuard implements RouteGuard {
    authService: AuthService
    
    constructor(authService: AuthService) {
        this.authService = authService
    }
    
    fn canActivate(context: BuildContext, params: Map<String, String>) -> Bool {
        return this.authService.isAdmin
    }
}

# Helper para crear router de testing
fn createTestRouter(authGuard: Option<AuthGuard>, adminGuard: Option<AdminGuard>) -> Router {
    guards = []
    
    if authGuard.isSome() {
        guards = [authGuard.unwrap()]
    }
    
    adminGuards = []
    if adminGuard.isSome() {
        adminGuards = [adminGuard.unwrap()]
    }
    
    return createRouter(
        routes: [
            route(
                path: "/",
                builder: (ctx, params) => HomeWidget(),
                name: Some("home")
            ),
            route(
                path: "/login",
                builder: (ctx, params) => LoginWidget(),
                name: Some("login")
            ),
            route(
                path: "/users",
                builder: (ctx, params) => UsersListWidget(),
                name: Some("users")
            ),
            route(
                path: "/users/:id",
                builder: (ctx, params) => UserDetailWidget(userId: params["id"]),
                name: Some("user-detail"),
                guards: guards
            ),
            route(
                path: "/users/:userId/posts/:postId",
                builder: (ctx, params) => PostDetailWidget(
                    userId: params["userId"],
                    postId: params["postId"]
                ),
                name: Some("post-detail")
            ),
            route(
                path: "/settings",
                builder: (ctx, params) => SettingsWidget(),
                name: Some("settings"),
                guards: guards
            ),
            route(
                path: "/admin",
                builder: (ctx, params) => AdminWidget(),
                name: Some("admin"),
                guards: adminGuards
            )
        ],
        notFoundBuilder: Some((ctx) => NotFoundWidget()),
        initialRoute: Some("/")
    )
}


"""
═══════════════════════════════════════════════════════════════════════════
TESTS: MULTI-STEP NAVIGATION FLOWS
═══════════════════════════════════════════════════════════════════════════
"""

@test
fn testMultiStepNavigationFlow() -> void {
    """Test flujo de navegación completo: Home → Users → Detail → Settings → Back"""
    
    context = BuildContext()
    router = createTestRouter(authGuard: None, adminGuard: None)
    navigator = createNavigator(
        router: router,
        context: context,
        initialPath: Some("/")
    )
    
    # Verificar inicio en Home
    assert(navigator.getCurrentPath().unwrap() == "/", "Should start at home")
    assert(navigator.getStackDepth() == 1, "Stack should have 1 entry")
    
    # Step 1: Home → Users
    result1 = navigator.push("/users")
    assert(result1.isSuccess(), "Push to /users should succeed")
    assert(navigator.getCurrentPath().unwrap() == "/users", "Should be at /users")
    assert(navigator.getStackDepth() == 2, "Stack should have 2 entries")
    
    # Step 2: Users → User Detail
    result2 = navigator.push("/users/123")
    assert(result2.isSuccess(), "Push to /users/123 should succeed")
    assert(navigator.getCurrentPath().unwrap() == "/users/123", "Should be at /users/123")
    assert(navigator.getStackDepth() == 3, "Stack should have 3 entries")
    
    # Step 3: User Detail → Settings
    result3 = navigator.push("/settings")
    assert(result3.isSuccess(), "Push to /settings should succeed")
    assert(navigator.getCurrentPath().unwrap() == "/settings", "Should be at /settings")
    assert(navigator.getStackDepth() == 4, "Stack should have 4 entries")
    
    # Step 4: Back (Settings → User Detail)
    result4 = navigator.pop()
    assert(result4.isSuccess(), "Pop should succeed")
    assert(navigator.getCurrentPath().unwrap() == "/users/123", "Should be back at /users/123")
    assert(navigator.getStackDepth() == 3, "Stack should have 3 entries")
    
    # Step 5: Back (User Detail → Users)
    result5 = navigator.pop()
    assert(result5.isSuccess(), "Pop should succeed")
    assert(navigator.getCurrentPath().unwrap() == "/users", "Should be back at /users")
    assert(navigator.getStackDepth() == 2, "Stack should have 2 entries")
    
    # Step 6: Back (Users → Home)
    result6 = navigator.pop()
    assert(result6.isSuccess(), "Pop should succeed")
    assert(navigator.getCurrentPath().unwrap() == "/", "Should be back at home")
    assert(navigator.getStackDepth() == 1, "Stack should have 1 entry")
    
    # No se puede hacer pop desde root
    result7 = navigator.pop()
    assert(result7.isInvalidOperation(), "Cannot pop from root")
    assert(navigator.getStackDepth() == 1, "Stack should still have 1 entry")
}

@test
fn testPopToRootFromDeepNavigation() -> void {
    """Test popToRoot desde navegación profunda"""
    
    context = BuildContext()
    router = createTestRouter(authGuard: None, adminGuard: None)
    navigator = createNavigator(
        router: router,
        context: context,
        initialPath: Some("/")
    )
    
    # Navegar profundamente: Home → Users → Detail → Settings
    navigator.push("/users")
    navigator.push("/users/123")
    navigator.push("/settings")
    
    assert(navigator.getStackDepth() == 4, "Stack should have 4 entries")
    
    # Pop to root
    result = navigator.popToRoot()
    assert(result.isSuccess(), "PopToRoot should succeed")
    assert(navigator.getCurrentPath().unwrap() == "/", "Should be at root")
    assert(navigator.getStackDepth() == 1, "Stack should have only 1 entry")
}

@test
fn testPopUntilSpecificRoute() -> void {
    """Test popUntil para volver a ruta específica"""
    
    context = BuildContext()
    router = createTestRouter(authGuard: None, adminGuard: None)
    navigator = createNavigator(
        router: router,
        context: context,
        initialPath: Some("/")
    )
    
    # Navegar: Home → Users → Detail → Settings
    navigator.push("/users")
    navigator.push("/users/123")
    navigator.push("/settings")
    
    assert(navigator.getStackDepth() == 4, "Stack should have 4 entries")
    
    # Pop hasta /users
    result = navigator.popUntil(entry => entry.getPath() == "/users")
    assert(result.isSuccess(), "PopUntil should succeed")
    assert(navigator.getCurrentPath().unwrap() == "/users", "Should be at /users")
    assert(navigator.getStackDepth() == 2, "Stack should have 2 entries")
}


"""
═══════════════════════════════════════════════════════════════════════════
TESTS: DEEP LINKING
═══════════════════════════════════════════════════════════════════════════
"""

@test
fn testDeepLinkingToNestedRoute() -> void {
    """Test navegación directa a ruta profunda"""
    
    context = BuildContext()
    router = createTestRouter(authGuard: None, adminGuard: None)
    navigator = createNavigator(
        router: router,
        context: context,
        initialPath: Some("/users/123")
    )
    
    # Verificar que inició directamente en la ruta profunda
    assert(navigator.getCurrentPath().unwrap() == "/users/123", "Should start at deep link")
    assert(navigator.getStackDepth() == 1, "Stack should have 1 entry")
    
    # Verificar que el widget tiene el parámetro correcto
    currentRoute = navigator.getCurrentRoute()
    assert(currentRoute.isSome(), "Should have current route")
    
    params = currentRoute.unwrap().getParams()
    assert(params["id"] == "123", "Should have correct user ID")
}

@test
fn testDeepLinkingWithMultipleParams() -> void {
    """Test deep linking con múltiples parámetros"""
    
    context = BuildContext()
    router = createTestRouter(authGuard: None, adminGuard: None)
    navigator = createNavigator(
        router: router,
        context: context,
        initialPath: Some("/users/456/posts/789")
    )
    
    # Verificar path
    assert(navigator.getCurrentPath().unwrap() == "/users/456/posts/789", "Should be at deep link")
    
    # Verificar parámetros
    currentRoute = navigator.getCurrentRoute()
    params = currentRoute.unwrap().getParams()
    assert(params["userId"] == "456", "Should have correct user ID")
    assert(params["postId"] == "789", "Should have correct post ID")
}

@test
fn testDeepLinkingWithQueryParams() -> void {
    """Test deep linking con query parameters"""
    
    context = BuildContext()
    router = createTestRouter(authGuard: None, adminGuard: None)
    navigator = createNavigator(
        router: router,
        context: context,
        initialPath: Some("/users/123?tab=posts&sort=date")
    )
    
    # Verificar path (sin query params)
    assert(navigator.getCurrentPath().unwrap() == "/users/123", "Should be at user detail")
    
    # Verificar parámetros (path + query)
    currentRoute = navigator.getCurrentRoute()
    params = currentRoute.unwrap().getParams()
    assert(params["id"] == "123", "Should have path param")
    assert(params["tab"] == "posts", "Should have query param tab")
    assert(params["sort"] == "date", "Should have query param sort")
}

@test
fn testDeepLinkingToInvalidRoute() -> void {
    """Test deep linking a ruta que no existe"""
    
    context = BuildContext()
    router = createTestRouter(authGuard: None, adminGuard: None)
    navigator = createNavigator(
        router: router,
        context: context,
        initialPath: Some("/invalid/route/xyz")
    )
    
    # Debería mostrar 404
    currentRoute = navigator.getCurrentRoute()
    assert(currentRoute.isSome(), "Should have current route")
    
    # Verificar que es la ruta de 404 (path vacío indica notFound)
    path = navigator.getCurrentPath().unwrap()
    assert(path == "/invalid/route/xyz" || path == "", "Should handle invalid route")
}


"""
═══════════════════════════════════════════════════════════════════════════
TESTS: ROUTE GUARDS EN ACCIÓN
═══════════════════════════════════════════════════════════════════════════
"""

@test
fn testNavigationBlockedByAuthGuard() -> void {
    """Test navegación bloqueada por guard de autenticación"""
    
    context = BuildContext()
    authService = AuthService()
    authGuard = AuthGuard(authService: authService)
    
    router = createTestRouter(authGuard: Some(authGuard), adminGuard: None)
    navigator = createNavigator(
        router: router,
        context: context,
        initialPath: Some("/")
    )
    
    # Intentar navegar a ruta protegida SIN autenticación
    result = navigator.push("/settings")
    assert(result.isBlocked(), "Navigation should be blocked")
    assert(navigator.getCurrentPath().unwrap() == "/", "Should still be at home")
    assert(navigator.getStackDepth() == 1, "Stack should not grow")
}

@test
fn testNavigationAllowedAfterLogin() -> void {
    """Test navegación permitida después de login"""
    
    context = BuildContext()
    authService = AuthService()
    authGuard = AuthGuard(authService: authService)
    
    router = createTestRouter(authGuard: Some(authGuard), adminGuard: None)
    navigator = createNavigator(
        router: router,
        context: context,
        initialPath: Some("/")
    )
    
    # Intentar navegar SIN autenticación
    result1 = navigator.push("/settings")
    assert(result1.isBlocked(), "Should be blocked before login")
    
    # Login
    authService.login()
    
    # Intentar navegar CON autenticación
    result2 = navigator.push("/settings")
    assert(result2.isSuccess(), "Should succeed after login")
    assert(navigator.getCurrentPath().unwrap() == "/settings", "Should be at settings")
    assert(navigator.getStackDepth() == 2, "Stack should grow")
}

@test
fn testRedirectToLoginWhenBlocked() -> void {
    """Test redirección a login cuando se bloquea navegación"""
    
    context = BuildContext()
    authService = AuthService()
    authGuard = AuthGuard(authService: authService)
    
    router = createTestRouter(authGuard: Some(authGuard), adminGuard: None)
    navigator = createNavigator(
        router: router,
        context: context,
        initialPath: Some("/")
    )
    
    # Intentar navegar a ruta protegida
    result1 = navigator.push("/settings")
    assert(result1.isBlocked(), "Should be blocked")
    
    # Redirigir a login (replace para que no quede en historial)
    result2 = navigator.replace("/login")
    assert(result2.isSuccess(), "Should redirect to login")
    assert(navigator.getCurrentPath().unwrap() == "/login", "Should be at login")
    assert(navigator.getStackDepth() == 1, "Stack should have 1 entry (replaced)")
    
    # Login
    authService.login()
    
    # Navegar a destino original
    result3 = navigator.replace("/settings")
    assert(result3.isSuccess(), "Should navigate after login")
    assert(navigator.getCurrentPath().unwrap() == "/settings", "Should be at settings")
}

@test
fn testMultipleGuardsAllMustPass() -> void {
    """Test múltiples guards: todos deben pasar"""
    
    context = BuildContext()
    authService = AuthService()
    authGuard = AuthGuard(authService: authService)
    adminGuard = AdminGuard(authService: authService)
    
    router = createTestRouter(authGuard: Some(authGuard), adminGuard: Some(adminGuard))
    navigator = createNavigator(
        router: router,
        context: context,
        initialPath: Some("/")
    )
    
    # Sin autenticación
    result1 = navigator.push("/admin")
    assert(result1.isBlocked(), "Should be blocked without auth")
    
    # Con autenticación pero sin admin
    authService.login()
    result2 = navigator.push("/admin")
    assert(result2.isBlocked(), "Should be blocked without admin role")
    
    # Con autenticación Y admin
    authService.loginAsAdmin()
    result3 = navigator.push("/admin")
    assert(result3.isSuccess(), "Should succeed with admin role")
    assert(navigator.getCurrentPath().unwrap() == "/admin", "Should be at admin")
}


"""
═══════════════════════════════════════════════════════════════════════════
TESTS: 404 HANDLING
═══════════════════════════════════════════════════════════════════════════
"""

@test
fn test404OnInvalidRoute() -> void {
    """Test 404 al navegar a ruta inválida"""
    
    context = BuildContext()
    router = createTestRouter(authGuard: None, adminGuard: None)
    navigator = createNavigator(
        router: router,
        context: context,
        initialPath: Some("/")
    )
    
    # Navegar a ruta que no existe
    result = navigator.push("/this/does/not/exist")
    assert(result.isNotFound(), "Should return NotFound")
    assert(navigator.getCurrentPath().unwrap() == "/", "Should stay at current route")
    assert(navigator.getStackDepth() == 1, "Stack should not grow")
}

@test
fn testNavigateBackFromInvalidRoute() -> void {
    """Test volver de 404 a ruta válida"""
    
    context = BuildContext()
    router = createTestRouter(authGuard: None, adminGuard: None)
    navigator = createNavigator(
        router: router,
        context: context,
        initialPath: Some("/")
    )
    
    # Navegar a rutas válidas
    navigator.push("/users")
    navigator.push("/users/123")
    
    # Intentar navegar a ruta inválida
    result1 = navigator.push("/invalid")
    assert(result1.isNotFound(), "Should be NotFound")
    assert(navigator.getCurrentPath().unwrap() == "/users/123", "Should stay at current")
    
    # Navegar de vuelta
    result2 = navigator.pop()
    assert(result2.isSuccess(), "Should pop successfully")
    assert(navigator.getCurrentPath().unwrap() == "/users", "Should be at /users")
}


"""
═══════════════════════════════════════════════════════════════════════════
TESTS: STATE PERSISTENCE
═══════════════════════════════════════════════════════════════════════════
"""

@test
fn testNavigationSnapshot() -> void {
    """Test crear snapshot del estado de navegación"""
    
    context = BuildContext()
    router = createTestRouter(authGuard: None, adminGuard: None)
    navigator = createNavigator(
        router: router,
        context: context,
        initialPath: Some("/")
    )
    
    # Navegar
    navigator.push("/users")
    navigator.push("/users/123")
    
    # Crear snapshot
    snapshot = navigator.getSnapshot()
    
    # Verificar snapshot
    assert(snapshot.stackDepth == 3, "Snapshot should have correct depth")
    assert(snapshot.currentRoute.isSome(), "Snapshot should have current route")
    assert(snapshot.currentRoute.unwrap().getPath() == "/users/123", "Should have correct current path")
    
    # Verificar history en snapshot
    history = snapshot.history
    assert(history.length == 3, "History should have 3 entries")
    assert(history[0].getPath() == "/", "First should be /")
    assert(history[1].getPath() == "/users", "Second should be /users")
    assert(history[2].getPath() == "/users/123", "Third should be /users/123")
}

@test
fn testSnapshotSerialization() -> void {
    """Test serialización de snapshot a Map"""
    
    context = BuildContext()
    router = createTestRouter(authGuard: None, adminGuard: None)
    navigator = createNavigator(
        router: router,
        context: context,
        initialPath: Some("/")
    )
    
    navigator.push("/users")
    
    # Crear y serializar snapshot
    snapshot = navigator.getSnapshot()
    map = snapshot.toMap()
    
    # Verificar estructura del map
    assert(map.containsKey("stackDepth"), "Should have stackDepth key")
    assert(map.containsKey("currentPath"), "Should have currentPath key")
    assert(map.containsKey("timestamp"), "Should have timestamp key")
    assert(map.containsKey("historyPaths"), "Should have historyPaths key")
    
    # Verificar valores
    assert(map["stackDepth"] == 2, "Should have correct depth")
    assert(map["currentPath"] == "/users", "Should have correct current path")
    
    historyPaths = map["historyPaths"]
    assert(historyPaths.length == 2, "Should have 2 history paths")
    assert(historyPaths[0] == "/", "First path should be /")
    assert(historyPaths[1] == "/users", "Second path should be /users")
}

@test
fn testRestoreNavigationState() -> void {
    """Test restaurar estado de navegación desde snapshot"""
    
    context = BuildContext()
    router = createTestRouter(authGuard: None, adminGuard: None)
    
    # Navigator 1: navegar y crear snapshot
    navigator1 = createNavigator(
        router: router,
        context: context,
        initialPath: Some("/")
    )
    navigator1.push("/users")
    navigator1.push("/users/123")
    
    snapshot = navigator1.getSnapshot()
    historyPaths = snapshot.history.map(entry => entry.getPath())
    
    # Navigator 2: restaurar desde snapshot
    navigator2 = createNavigator(
        router: router,
        context: context,
        initialPath: Some("/")
    )
    
    # Reconstruir stack (sin transiciones)
    (1..historyPaths.length).forEach(i => {
        navigator2.push(historyPaths[i], transition: TransitionConfig.none())
    })
    
    # Verificar que el estado es igual
    assert(navigator2.getStackDepth() == 3, "Should have same depth")
    assert(navigator2.getCurrentPath().unwrap() == "/users/123", "Should be at same route")
}


"""
═══════════════════════════════════════════════════════════════════════════
TESTS: CONCURRENT NAVIGATION
═══════════════════════════════════════════════════════════════════════════
"""

@test
fn testMultiplePushesInQuickSuccession() -> void {
    """Test múltiples pushes rápidos"""
    
    context = BuildContext()
    router = createTestRouter(authGuard: None, adminGuard: None)
    navigator = createNavigator(
        router: router,
        context: context,
        initialPath: Some("/")
    )
    
    # Múltiples pushes
    result1 = navigator.push("/users")
    result2 = navigator.push("/users/123")
    result3 = navigator.push("/settings")
    
    # Todos deberían tener éxito
    assert(result1.isSuccess(), "First push should succeed")
    assert(result2.isSuccess(), "Second push should succeed")
    assert(result3.isSuccess(), "Third push should succeed")
    
    # Estado final correcto
    assert(navigator.getStackDepth() == 4, "Stack should have 4 entries")
    assert(navigator.getCurrentPath().unwrap() == "/settings", "Should be at last route")
}

@test
fn testPushPopPushSequence() -> void {
    """Test secuencia push-pop-push"""
    
    context = BuildContext()
    router = createTestRouter(authGuard: None, adminGuard: None)
    navigator = createNavigator(
        router: router,
        context: context,
        initialPath: Some("/")
    )
    
    # Push
    navigator.push("/users")
    assert(navigator.getStackDepth() == 2, "Should have 2 entries")
    
    # Pop
    navigator.pop()
    assert(navigator.getStackDepth() == 1, "Should have 1 entry")
    
    # Push again
    navigator.push("/settings")
    assert(navigator.getStackDepth() == 2, "Should have 2 entries")
    assert(navigator.getCurrentPath().unwrap() == "/settings", "Should be at /settings")
}


"""
═══════════════════════════════════════════════════════════════════════════
TESTS: NAMED ROUTES FLOW
═══════════════════════════════════════════════════════════════════════════
"""

@test
fn testCompleteNamedRouteFlow() -> void {
    """Test flujo completo usando solo rutas nombradas"""
    
    context = BuildContext()
    router = createTestRouter(authGuard: None, adminGuard: None)
    navigator = createNavigator(
        router: router,
        context: context,
        initialPath: Some("/")
    )
    
    # Navegar usando nombres
    result1 = navigator.pushNamed("users", {})
    assert(result1.isSuccess(), "Push to users should succeed")
    assert(navigator.getCurrentPath().unwrap() == "/users", "Should be at /users")
    
    result2 = navigator.pushNamed("user-detail", {id: "456"})
    assert(result2.isSuccess(), "Push to user-detail should succeed")
    assert(navigator.getCurrentPath().unwrap() == "/users/456", "Should be at /users/456")
    
    result3 = navigator.pushNamed("settings", {})
    assert(result3.isSuccess(), "Push to settings should succeed")
    assert(navigator.getCurrentPath().unwrap() == "/settings", "Should be at /settings")
    
    # Verificar stack
    assert(navigator.getStackDepth() == 4, "Stack should have 4 entries")
}

@test
fn testReplaceNamedRoute() -> void {
    """Test replace con rutas nombradas"""
    
    context = BuildContext()
    router = createTestRouter(authGuard: None, adminGuard: None)
    navigator = createNavigator(
        router: router,
        context: context,
        initialPath: Some("/")
    )
    
    navigator.pushNamed("login", {})
    assert(navigator.getStackDepth() == 2, "Should have 2 entries")
    
    # Replace login con home (patrón post-login)
    result = navigator.replaceNamed("home", {})
    assert(result.isSuccess(), "Replace should succeed")
    assert(navigator.getCurrentPath().unwrap() == "/", "Should be at home")
    assert(navigator.getStackDepth() == 2, "Stack depth should not change")
}


"""
═══════════════════════════════════════════════════════════════════════════
TESTS: TRANSITIONS
═══════════════════════════════════════════════════════════════════════════
"""

@test
fn testDifferentTransitionTypes() -> void {
    """Test que diferentes transiciones se aplican correctamente"""
    
    context = BuildContext()
    router = createTestRouter(authGuard: None, adminGuard: None)
    navigator = createNavigator(
        router: router,
        context: context,
        initialPath: Some("/")
    )
    
    # Push con slide (default)
    result1 = navigator.push("/users")
    entry1 = navigator.getCurrentRoute().unwrap()
    assert(entry1.transition.type == TransitionType.Slide, "Should use Slide transition")
    
    # Push con fade
    result2 = navigator.push("/users/123", transition: TransitionConfig.fade(500))
    entry2 = navigator.getCurrentRoute().unwrap()
    assert(entry2.transition.type == TransitionType.Fade, "Should use Fade transition")
    assert(entry2.transition.duration == 500, "Should have correct duration")
    
    # Push con scale
    result3 = navigator.push("/settings", transition: TransitionConfig.scale(300))
    entry3 = navigator.getCurrentRoute().unwrap()
    assert(entry3.transition.type == TransitionType.Scale, "Should use Scale transition")
    
    # Push sin transición
    result4 = navigator.push("/admin", transition: TransitionConfig.none())
    entry4 = navigator.getCurrentRoute().unwrap()
    assert(entry4.transition.type == TransitionType.None, "Should have no transition")
    assert(entry4.transition.duration == 0, "Duration should be 0")
}

@test
fn testTransitionOnPop() -> void {
    """Test transición custom en pop"""
    
    context = BuildContext()
    router = createTestRouter(authGuard: None, adminGuard: None)
    navigator = createNavigator(
        router: router,
        context: context,
        initialPath: Some("/")
    )
    
    navigator.push("/users")
    navigator.push("/users/123")
    
    # Pop con transición custom (fade)
    result = navigator.pop(transition: TransitionConfig.fade(400))
    assert(result.isSuccess(), "Pop should succeed")
    
    # La transición se usa pero no se almacena (ya se aplicó)
    assert(navigator.getCurrentPath().unwrap() == "/users", "Should be at /users")
}


"""
═══════════════════════════════════════════════════════════════════════════
TESTS: CALLBACKS
═══════════════════════════════════════════════════════════════════════════
"""

@test
fn testOnRouteChangedCallbackOnPush() -> void {
    """Test callback ejecutado en push"""
    
    context = BuildContext()
    router = createTestRouter(authGuard: None, adminGuard: None)
    
    state callbackExecuted: Bool = false
    state oldPath: String = ""
    state newPath: String = ""
    
    callback = (Option<RouteEntry> old, Option<RouteEntry> new) => {
        callbackExecuted = true
        oldPath = old.map(e => e.getPath()).unwrapOr("none")
        newPath = new.map(e => e.getPath()).unwrapOr("none")
    }
    
    navigator = Navigator(
        router: router,
        context: context,
        onRouteChanged: Some(callback)
    )
    
    # Initial navigation (constructor)
    assert(callbackExecuted == false, "Callback should not execute on construction")
    
    # Push
    navigator.push("/users")
    
    assert(callbackExecuted == true, "Callback should execute on push")
    assert(oldPath == "/", "Old path should be /")
    assert(newPath == "/users", "New path should be /users")
}

@test
fn testOnRouteChangedCallbackOnPop() -> void {
    """Test callback ejecutado en pop"""
    
    context = BuildContext()
    router = createTestRouter(authGuard: None, adminGuard: None)
    
    state callbackCount: Number = 0
    state lastOldPath: String = ""
    state lastNewPath: String = ""
    
    callback = (Option<RouteEntry> old, Option<RouteEntry> new) => {
        callbackCount = callbackCount + 1
        lastOldPath = old.map(e => e.getPath()).unwrapOr("none")
        lastNewPath = new.map(e => e.getPath()).unwrapOr("none")
    }
    
    navigator = Navigator(
        router: router,
        context: context,
        onRouteChanged: Some(callback)
    )
    
    navigator.push("/users")  # Callback count = 1
    navigator.push("/users/123")  # Callback count = 2
    
    assert(callbackCount == 2, "Should have 2 callbacks so far")
    
    navigator.pop()  # Callback count = 3
    
    assert(callbackCount == 3, "Should have 3 callbacks total")
    assert(lastOldPath == "/users/123", "Last old path should be /users/123")
    assert(lastNewPath == "/users", "Last new path should be /users")
}


"""
═══════════════════════════════════════════════════════════════════════════
TEST RUNNER
═══════════════════════════════════════════════════════════════════════════
"""

fn main() -> void {
    print("═══════════════════════════════════════════════════════════")
    print("  INTEGRATION TESTS: Navigation System")
    print("═══════════════════════════════════════════════════════════")
    print("")
    
    # Multi-step flows
    print("▶ Multi-step Navigation Flows...")
    testMultiStepNavigationFlow()
    print("  ✓ testMultiStepNavigationFlow")
    
    testPopToRootFromDeepNavigation()
    print("  ✓ testPopToRootFromDeepNavigation")
    
    testPopUntilSpecificRoute()
    print("  ✓ testPopUntilSpecificRoute")
    
    # Deep linking
    print("")
    print("▶ Deep Linking...")
    testDeepLinkingToNestedRoute()
    print("  ✓ testDeepLinkingToNestedRoute")
    
    testDeepLinkingWithMultipleParams()
    print("  ✓ testDeepLinkingWithMultipleParams")
    
    testDeepLinkingWithQueryParams()
    print("  ✓ testDeepLinkingWithQueryParams")
    
    testDeepLinkingToInvalidRoute()
    print("  ✓ testDeepLinkingToInvalidRoute")
    
    # Route guards
    print("")
    print("▶ Route Guards in Action...")
    testNavigationBlockedByAuthGuard()
    print("  ✓ testNavigationBlockedByAuthGuard")
    
    testNavigationAllowedAfterLogin()
    print("  ✓ testNavigationAllowedAfterLogin")
    
    testRedirectToLoginWhenBlocked()
    print("  ✓ testRedirectToLoginWhenBlocked")
    
    testMultipleGuardsAllMustPass()
    print("  ✓ testMultipleGuardsAllMustPass")
    
    # 404 handling
    print("")
    print("▶ 404 Handling...")
    test404OnInvalidRoute()
    print("  ✓ test404OnInvalidRoute")
    
    testNavigateBackFromInvalidRoute()
    print("  ✓ testNavigateBackFromInvalidRoute")
    
    # State persistence
    print("")
    print("▶ State Persistence...")
    testNavigationSnapshot()
    print("  ✓ testNavigationSnapshot")
    
    testSnapshotSerialization()
    print("  ✓ testSnapshotSerialization")
    
    testRestoreNavigationState()
    print("  ✓ testRestoreNavigationState")
    
    # Concurrent navigation
    print("")
    print("▶ Concurrent Navigation...")
    testMultiplePushesInQuickSuccession()
    print("  ✓ testMultiplePushesInQuickSuccession")
    
    testPushPopPushSequence()
    print("  ✓ testPushPopPushSequence")
    
    # Named routes
    print("")
    print("▶ Named Routes Flow...")
    testCompleteNamedRouteFlow()
    print("  ✓ testCompleteNamedRouteFlow")
    
    testReplaceNamedRoute()
    print("  ✓ testReplaceNamedRoute")
    
    # Transitions
    print("")
    print("▶ Transitions...")
    testDifferentTransitionTypes()
    print("  ✓ testDifferentTransitionTypes")
    
    testTransitionOnPop()
    print("  ✓ testTransitionOnPop")
    
    # Callbacks
    print("")
    print("▶ Callbacks...")
    testOnRouteChangedCallbackOnPush()
    print("  ✓ testOnRouteChangedCallbackOnPush")
    
    testOnRouteChangedCallbackOnPop()
    print("  ✓ testOnRouteChangedCallbackOnPop")
    
    print("")
    print("═══════════════════════════════════════════════════════════")
    print("  ✅ ALL INTEGRATION TESTS PASSED (25 tests)")
    print("═══════════════════════════════════════════════════════════")
}
