/**
 * EventTarget Interface - Standard Library
 * 
 * TASK-035O: Implementar event propagation
 * Historia: VELA-575 - Dependency Injection
 * Epic: VELA-573 - Sistema de Reactividad
 * Sprint: 14
 * 
 * Interface para objetos que pueden ser targets de eventos y participar
 * en event propagation chains. Inspirado en DOM EventTarget API.
 * 
 * @module system:events
 * @since 1.0.0
 */

import 'system:reactive'
import 'system:events' show { Event, EventListener }


/**
 * Interface para objetos que pueden recibir eventos y propagarlos.
 * 
 * Cualquier objeto que implemente EventTarget puede:
 * - Recibir eventos via dispatchEvent()
 * - Propagar eventos a través de parent chain
 * - Participar en capturing/bubbling phases
 * 
 * Para participar en propagation, el objeto debe:
 * 1. Implementar EventTarget interface
 * 2. Tener propiedad 'parent' para formar hierarchy
 * 
 * @example
 * ```vela
 * class Button implements EventTarget {
 *     parent: Option<EventTarget> = None
 *     
 *     fn click() -> void {
 *         event = Event("click", this, bubbles=True)
 *         this.dispatchEvent(event)
 *     }
 * }
 * 
 * class Panel implements EventTarget {
 *     parent: Option<EventTarget> = None
 *     button: Button
 *     
 *     constructor() {
 *         this.button = Button()
 *         this.button.parent = Some(this)
 *         
 *         // Listen to button clicks (bubbling)
 *         this.addEventListener("click", (e) => {
 *             print("Panel received click from ${e.target}")
 *         })
 *     }
 * }
 * ```
 * 
 * @interface EventTarget
 */
interface EventTarget {
    
    /**
     * Parent in propagation hierarchy.
     * Events will bubble/capture through this chain.
     * 
     * @type {Option<EventTarget>}
     */
    parent: Option<EventTarget>
    
    /**
     * Add event listener to this target.
     * 
     * @param eventType - Event type to listen for
     * @param listener - Callback function
     * @param useCapture - Listen during capturing phase (default: false)
     * @returns Subscription for cleanup
     * 
     * @example
     * ```vela
     * button.addEventListener("click", (e) => {
     *     print("Clicked!")
     * })
     * 
     * // Listen during capturing phase
     * panel.addEventListener("click", (e) => {
     *     print("Capturing phase")
     * }, useCapture=True)
     * ```
     */
    fn addEventListener(
        eventType: String, 
        listener: EventListener,
        useCapture: Bool
    ) -> Subscription
    
    /**
     * Remove event listener from this target.
     * 
     * @param eventType - Event type
     * @param listener - Listener to remove
     * @param useCapture - Remove from capturing listeners
     * 
     * @example
     * ```vela
     * handler = (e) => { print("Click") }
     * button.addEventListener("click", handler)
     * button.removeEventListener("click", handler)
     * ```
     */
    fn removeEventListener(
        eventType: String,
        listener: EventListener,
        useCapture: Bool
    ) -> void
    
    /**
     * Dispatch event to this target with propagation.
     * 
     * Executes full propagation cycle:
     * 1. CAPTURING: root → target
     * 2. AT_TARGET: target
     * 3. BUBBLING: target → root (if event.bubbles)
     * 
     * @param event - Event to dispatch
     * @returns True if event was not cancelled
     * 
     * @example
     * ```vela
     * event = Event("click", clickData, bubbles=True)
     * button.dispatchEvent(event)
     * ```
     */
    fn dispatchEvent(event: Event<T>) -> Bool
}


/**
 * Base implementation of EventTarget.
 * 
 * Provee implementación completa de EventTarget usando EventBus
 * para manejo de listeners. Clases pueden extender EventTargetBase
 * para ganar event propagation support.
 * 
 * Features:
 * - Automatic propagation path composition
 * - Capturing and bubbling support
 * - Error isolation
 * - Thread-safe
 * 
 * @example
 * ```vela
 * class Component extends EventTargetBase {
 *     name: String
 *     
 *     constructor(name: String) {
 *         super()
 *         this.name = name
 *     }
 *     
 *     fn trigger() -> void {
 *         event = Event("triggered", { component: this.name })
 *         this.dispatchEvent(event)
 *     }
 * }
 * 
 * // Build hierarchy
 * root = Component("root")
 * child = Component("child")
 * grandchild = Component("grandchild")
 * 
 * child.parent = Some(root)
 * grandchild.parent = Some(child)
 * 
 * // Listen at each level
 * root.addEventListener("triggered", (e) => {
 *     print("Root heard: ${e.payload.component}")
 * })
 * 
 * child.addEventListener("triggered", (e) => {
 *     print("Child heard: ${e.payload.component}")
 * })
 * 
 * // Trigger from grandchild (will bubble to child and root)
 * grandchild.trigger()
 * ```
 * 
 * @class EventTargetBase
 * @implements EventTarget
 */
class EventTargetBase implements EventTarget {
    
    /**
     * Parent in propagation hierarchy.
     * @public
     */
    public parent: Option<EventTarget> = None
    
    /**
     * Internal event bus for listener management.
     * @private
     */
    private _bus: EventBus<T>
    
    /**
     * Constructor.
     * Initializes internal event bus.
     */
    constructor() {
        this._bus = EventBus<T>()
    }
    
    /**
     * {@inheritDoc EventTarget.addEventListener}
     */
    fn addEventListener(
        eventType: String, 
        listener: EventListener,
        useCapture: Bool = false
    ) -> Subscription {
        // TODO: Implement capturing vs bubbling listener separation
        // For now, all listeners are treated as bubbling
        return this._bus.on(eventType, listener)
    }
    
    /**
     * {@inheritDoc EventTarget.removeEventListener}
     */
    fn removeEventListener(
        eventType: String,
        listener: EventListener,
        useCapture: Bool = false
    ) -> void {
        this._bus.off(eventType, listener)
    }
    
    /**
     * {@inheritDoc EventTarget.dispatchEvent}
     */
    fn dispatchEvent(event: Event<T>) -> Bool {
        // Set target if not already set
        if event.target == None {
            event.target = Some(this)
        }
        
        // Dispatch with propagation
        return this._bus.dispatch_event(
            event, 
            target=this,
            use_capturing=True,
            use_bubbling=event.bubbles
        )
    }
    
    /**
     * Get parent EventTarget (helper for propagation).
     * @returns Parent target or None
     */
    fn getParent() -> Option<EventTarget> {
        return this.parent
    }
    
    /**
     * Set parent EventTarget (helper for hierarchy building).
     * @param parent - New parent target
     */
    fn setParent(parent: EventTarget) -> void {
        this.parent = Some(parent)
    }
}


/**
 * Helper function to create event target hierarchy.
 * 
 * @param targets - List of targets (child to parent order)
 * @returns Root target
 * 
 * @example
 * ```vela
 * button = EventTargetBase()
 * panel = EventTargetBase()
 * window = EventTargetBase()
 * 
 * // Build hierarchy: button → panel → window
 * createHierarchy([button, panel, window])
 * 
 * // Now events on button will bubble to panel and window
 * ```
 */
public fn createHierarchy(targets: List<EventTarget>) -> EventTarget {
    if targets.length == 0 {
        throw Error("createHierarchy requires at least one target")
    }
    
    // Link targets: targets[i].parent = targets[i+1]
    for i in 0..(targets.length - 1) {
        targets[i].parent = Some(targets[i + 1])
    }
    
    return targets[targets.length - 1]  // Return root
}


/**
 * Helper to find path from target to root.
 * 
 * @param target - Starting target
 * @returns List of targets from target to root
 * 
 * @example
 * ```vela
 * path = getEventPath(button)
 * // Returns: [button, panel, window]
 * ```
 */
public fn getEventPath(target: EventTarget) -> List<EventTarget> {
    path: List<EventTarget> = []
    current: Option<EventTarget> = Some(target)
    
    while let Some(t) = current {
        path.push(t)
        current = t.parent
    }
    
    return path
}
