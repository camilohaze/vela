//! Tests for JavaScript Code Generator

use crate::ir::{IRModule, IRFunction, IRInstruction, IRExpr, IRType, Value, BinaryOp};
use super::JSGenerator;

#[test]
fn test_generate_empty_module() {
    let mut generator = JSGenerator::new();
    let module = IRModule::new("empty".to_string());

    let js_code = generator.generate_module(&module);

    assert!(js_code.contains("// Generated by Vela JS Codegen"));
    assert!(js_code.contains("// Runtime: vela-runtime.js"));
    assert!(js_code.contains("empty"));
}

#[test]
fn test_generate_module_with_functions() {
    let mut generator = JSGenerator::new();
    let mut module = IRModule::new("test_module".to_string());

    // Add a simple function
    let mut function = IRFunction::new("add".to_string(), IRType::Int);
    function.add_param("a".to_string(), IRType::Int);
    function.add_param("b".to_string(), IRType::Int);
    function.add_instruction(IRInstruction::Return);

    module.add_function(function);

    let js_code = generator.generate_module(&module);

    assert!(js_code.contains("function add(a, b)"));
    assert!(js_code.contains("return;"));
}

#[test]
fn test_generate_function_with_locals() {
    let mut generator = JSGenerator::new();

    let mut function = IRFunction::new("test".to_string(), IRType::Void);
    function.add_param("input".to_string(), IRType::String);
    function.add_local("result".to_string(), IRType::Int);
    function.add_local("flag".to_string(), IRType::Bool);

    // Add some instructions
    function.add_instruction(IRInstruction::DeclareVar {
        name: "temp".to_string(),
        ty: IRType::Float,
    });
    function.add_instruction(IRInstruction::Return);

    let js_code = generator.generate_function(&function);

    assert!(js_code.contains("function test(input)"));
    assert!(js_code.contains("let result: number;"));
    assert!(js_code.contains("let flag: boolean;"));
    assert!(js_code.contains("let temp: number;"));
    assert!(js_code.contains("return;"));
}

#[test]
fn test_generate_expressions() {
    let mut generator = JSGenerator::new();

    // Test binary operation
    let expr = IRExpr::BinaryOp(
        BinaryOp::Add,
        Box::new(IRExpr::Const(Value::Int(5))),
        Box::new(IRExpr::Const(Value::Int(3)))
    );

    let js_expr = generator.generate_expression(&expr);
    assert_eq!(js_expr, "(5 + 3)");

    // Test variable reference
    let expr = IRExpr::Var("counter".to_string());
    let js_expr = generator.generate_expression(&expr);
    assert_eq!(js_expr, "counter");
}

#[test]
fn test_generate_complex_function() {
    let mut generator = JSGenerator::new();

    let mut function = IRFunction::new("calculate".to_string(), IRType::Int);
    function.add_param("x".to_string(), IRType::Int);
    function.add_param("y".to_string(), IRType::Int);
    function.add_local("sum".to_string(), IRType::Int);

    // sum = x + y
    function.add_instruction(IRInstruction::AssignVar {
        name: "sum".to_string(),
        value: IRExpr::BinaryOp(
            BinaryOp::Add,
            Box::new(IRExpr::Var("x".to_string())),
            Box::new(IRExpr::Var("y".to_string()))
        ),
    });

    // return sum
    function.add_instruction(IRInstruction::Return);

    let js_code = generator.generate_function(&function);

    assert!(js_code.contains("function calculate(x, y)"));
    assert!(js_code.contains("let sum: number;"));
    assert!(js_code.contains("sum = (x + y);"));
    assert!(js_code.contains("return;"));
}

#[test]
fn test_generate_function_calls() {
    let mut generator = JSGenerator::new();

    let expr = IRExpr::Call {
        function: "println".to_string(),
        args: vec![
            IRExpr::Const(Value::String("Hello World".to_string()))
        ]
    };

    let js_expr = generator.generate_expression(&expr);
    assert_eq!(js_expr, "println(\"Hello World\")");
}

#[test]
fn test_generate_array_operations() {
    let mut generator = JSGenerator::new();

    // Array access
    let expr = IRExpr::ArrayAccess {
        array: Box::new(IRExpr::Var("arr".to_string())),
        index: Box::new(IRExpr::Const(Value::Int(0)))
    };

    let js_expr = generator.generate_expression(&expr);
    assert_eq!(js_expr, "arr[0]");

    // Property access
    let expr = IRExpr::PropertyAccess {
        object: Box::new(IRExpr::Var("obj".to_string())),
        property: "name".to_string()
    };

    let js_expr = generator.generate_expression(&expr);
    assert_eq!(js_expr, "obj.name");
}

#[test]
fn test_type_generation() {
    let mut generator = JSGenerator::new();

    assert_eq!(generator.generate_type(&IRType::Int), "number");
    assert_eq!(generator.generate_type(&IRType::String), "string");
    assert_eq!(generator.generate_type(&IRType::Bool), "boolean");
    assert_eq!(generator.generate_type(&IRType::Void), "void");
    assert_eq!(generator.generate_type(&IRType::Array(Box::new(IRType::String))), "string[]");
    assert_eq!(generator.generate_type(&IRType::Object("User".to_string())), "User");
}

#[test]
fn test_module_with_globals() {
    let mut generator = JSGenerator::new();
    let mut module = IRModule::new("globals_test".to_string());

    // Add a global variable
    let global = crate::ir::IRGlobal {
        name: "PI".to_string(),
        ty: IRType::Float,
        initial_value: Some(Value::Float(3.14159)),
    };

    // Note: IRModule doesn't have add_global method in the current implementation
    // This test would need to be updated when the IR structure is complete

    let js_code = generator.generate_module(&module);
    assert!(js_code.contains("globals_test"));
}

#[test]
fn test_runtime_integration() {
    let mut generator = JSGenerator::new();
    let module = IRModule::new("runtime_test".to_string());

    let js_code = generator.generate_module(&module);

    // Should include runtime comment
    assert!(js_code.contains("// Runtime: vela-runtime.js"));
    assert!(js_code.contains("// Generated by Vela JS Codegen"));
}

#[test]
fn test_empty_function() {
    let mut generator = JSGenerator::new();

    let function = IRFunction::new("empty".to_string(), IRType::Void);

    let js_code = generator.generate_function(&function);

    assert!(js_code.contains("function empty()"));
    assert!(js_code.contains("{\n}\n"));
}

#[test]
fn test_function_with_multiple_instructions() {
    let mut generator = JSGenerator::new();

    let mut function = IRFunction::new("complex".to_string(), IRType::Void);
    function.add_param("input".to_string(), IRType::Int);

    function.add_instruction(IRInstruction::DeclareVar {
        name: "doubled".to_string(),
        ty: IRType::Int,
    });

    function.add_instruction(IRInstruction::AssignVar {
        name: "doubled".to_string(),
        value: IRExpr::BinaryOp(
            BinaryOp::Mul,
            Box::new(IRExpr::Var("input".to_string())),
            Box::new(IRExpr::Const(Value::Int(2)))
        ),
    });

    function.add_instruction(IRInstruction::Call {
        function: "println".to_string(),
        arg_count: 1,
    });

    function.add_instruction(IRInstruction::Return);

    let js_code = generator.generate_function(&function);

    assert!(js_code.contains("function complex(input)"));
    assert!(js_code.contains("let doubled: number;"));
    assert!(js_code.contains("doubled = (input * 2);"));
    assert!(js_code.contains("println();"));
    assert!(js_code.contains("return _temp0;"));
}