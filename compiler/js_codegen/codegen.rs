//! JavaScript Code Generator Implementation
//!
//! Converts Vela IR to JavaScript code

use std::collections::HashMap;
use crate::ir::{
    IRModule, IRFunction, IRInstruction, IRExpr, IRType, Value,
    BinaryOp, UnaryOp, IRParam, IRLocal, IRGlobal
};

/// Main JavaScript code generator
pub struct JSCodegen {
    indent_level: usize,
    in_function: bool,
    variables: HashMap<String, String>, // name -> js_name
    stack: Vec<String>, // Virtual stack for expression evaluation
}

impl JSCodegen {
    pub fn new() -> Self {
        Self {
            indent_level: 0,
            in_function: false,
            variables: HashMap::new(),
            stack: Vec::new(),
        }
    }

    /// Generate JavaScript code for a complete module
    pub fn generate_module(&mut self, module: &IRModule) -> String {
        let mut output = String::new();

        // Add runtime imports
        output.push_str("// Generated by Vela JS Codegen\n");
        output.push_str("// Runtime: vela-runtime.js\n\n");

        // Generate globals
        for global in &module.globals {
            output.push_str(&self.generate_global(global));
            output.push_str("\n");
        }

        if !module.globals.is_empty() {
            output.push_str("\n");
        }

        // Generate functions
        for function in &module.functions {
            output.push_str(&self.generate_function(function));
            output.push_str("\n\n");
        }

        output
    }

    /// Generate JavaScript code for a function
    pub fn generate_function(&mut self, function: &IRFunction) -> String {
        self.in_function = true;
        self.variables.clear();

        let mut output = String::new();

        // Function signature
        output.push_str("function ");
        output.push_str(&function.name);
        output.push_str("(");

        // Parameters
        let params: Vec<String> = function.params.iter()
            .map(|p| p.name.clone())
            .collect();
        output.push_str(&params.join(", "));

        output.push_str(") {\n");

        self.indent_level += 1;

        // Local variables
        for local in &function.locals {
            let indent = self.get_indent();
            let js_type = self.type_to_js(&local.ty);
            output.push_str(&format!("{}let {}: {};\n", indent, local.name, js_type));
        }

        if !function.locals.is_empty() {
            output.push_str("\n");
        }

        // Generate function body
        output.push_str(&self.generate_function_body(&function.body));

        self.indent_level -= 1;
        output.push_str("}\n");

        self.in_function = false;
        output
    }

    /// Generate function body from IR instructions
    fn generate_function_body(&mut self, instructions: &[IRInstruction]) -> String {
        let mut output = String::new();
        let mut i = 0;

        while i < instructions.len() {
            match &instructions[i] {
                IRInstruction::DeclareVar { name, ty } => {
                    let indent = self.get_indent();
                    let js_type = self.type_to_js(ty);
                    output.push_str(&format!("{}let {}: {};\n", indent, name, js_type));
                }

                IRInstruction::AssignVar { name, value } => {
                    let indent = self.get_indent();
                    let expr = self.generate_expression(value);
                    output.push_str(&format!("{}{} = {};\n", indent, name, expr));
                }

                IRInstruction::LoadConst(value) => {
                    // Push constant value to virtual stack
                    let js_value = self.generate_value(value);
                    self.stack.push(js_value);
                }

                IRInstruction::Return => {
                    let indent = self.get_indent();
                    if let Some(value) = self.stack.pop() {
                        output.push_str(&format!("{}return {};\n", indent, value));
                    } else {
                        output.push_str(&format!("{}return;\n", indent));
                    }
                }

                IRInstruction::Call { function, arg_count } => {
                    // Pop arguments from stack
                    let mut args = Vec::new();
                    for _ in 0..*arg_count {
                        if let Some(arg) = self.stack.pop() {
                            args.push(arg);
                        }
                    }
                    args.reverse(); // Stack is LIFO, so reverse to get correct order
                    
                    let indent = self.get_indent();
                    let args_str = args.join(", ");
                    output.push_str(&format!("{}{}({});\n", indent, function, args_str));
                }

                IRInstruction::Label(label) => {
                    let indent = self.get_indent();
                    output.push_str(&format!("{}{}:\n", indent, label));
                }

                IRInstruction::Jump(label) => {
                    // JavaScript doesn't have goto, so we'd need to restructure
                    // For now, this is a placeholder
                }

                _ => {
                    // Handle other instructions...
                }
            }
            i += 1;
        }

        output
    }

    /// Generate JavaScript code for an expression
    pub fn generate_expression(&mut self, expr: &IRExpr) -> String {
        match expr {
            IRExpr::Var(name) => name.clone(),
            IRExpr::Const(value) => self.generate_value(value),
            IRExpr::BinaryOp(op, left, right) => {
                let left_js = self.generate_expression(left);
                let right_js = self.generate_expression(right);
                let op_js = self.binary_op_to_js(op);
                format!("({} {} {})", left_js, op_js, right_js)
            }
            IRExpr::UnaryOp(op, expr) => {
                let expr_js = self.generate_expression(expr);
                let op_js = self.unary_op_to_js(op);
                format!("({}{})", op_js, expr_js)
            }
            IRExpr::Call { function, args } => {
                let args_js: Vec<String> = args.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                format!("{}({})", function, args_js.join(", "))
            }
            IRExpr::ArrayAccess { array, index } => {
                let array_js = self.generate_expression(array);
                let index_js = self.generate_expression(index);
                format!("{}[{}]", array_js, index_js)
            }
            IRExpr::PropertyAccess { object, property } => {
                let object_js = self.generate_expression(object);
                format!("{}.{}", object_js, property)
            }
        }
    }

    /// Generate JavaScript code for a value
    fn generate_value(&self, value: &Value) -> String {
        match value {
            Value::Bool(b) => b.to_string(),
            Value::Int(i) => i.to_string(),
            Value::Float(f) => f.to_string(),
            Value::String(s) => format!("\"{}\"", s),
            Value::Null => "null".to_string(),
        }
    }

    /// Generate JavaScript code for a global variable
    fn generate_global(&mut self, global: &IRGlobal) -> String {
        let mut output = format!("let {}: {}", global.name, self.type_to_js(&global.ty));

        if let Some(initial) = &global.initial_value {
            output.push_str(&format!(" = {}", self.generate_value(initial)));
        }

        output.push(';');
        output
    }

    /// Convert IR type to JavaScript type annotation
    pub fn generate_type(&mut self, ty: &IRType) -> String {
        self.type_to_js(ty)
    }

    /// Convert IR type to JavaScript type string
    fn type_to_js(&self, ty: &IRType) -> String {
        match ty {
            IRType::Void => "void".to_string(),
            IRType::Bool => "boolean".to_string(),
            IRType::Int => "number".to_string(),
            IRType::Float => "number".to_string(),
            IRType::String => "string".to_string(),
            IRType::Array(element_type) => format!("{}[]", self.type_to_js(element_type)),
            IRType::Object(name) => name.clone(),
        }
    }

    /// Convert binary operator to JavaScript
    fn binary_op_to_js(&self, op: &BinaryOp) -> &'static str {
        match op {
            BinaryOp::Add => "+",
            BinaryOp::Sub => "-",
            BinaryOp::Mul => "*",
            BinaryOp::Div => "/",
            BinaryOp::Mod => "%",
            BinaryOp::Eq => "===",
            BinaryOp::Ne => "!==",
            BinaryOp::Lt => "<",
            BinaryOp::Le => "<=",
            BinaryOp::Gt => ">",
            BinaryOp::Ge => ">=",
            BinaryOp::And => "&&",
            BinaryOp::Or => "||",
        }
    }

    /// Convert unary operator to JavaScript
    fn unary_op_to_js(&self, op: &UnaryOp) -> &'static str {
        match op {
            UnaryOp::Neg => "-",
            UnaryOp::Not => "!",
        }
    }

    /// Get current indentation string
    fn get_indent(&self) -> String {
        "  ".repeat(self.indent_level)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ir::{IRModule, IRFunction, IRInstruction, IRExpr, IRType, Value};

    #[test]
    fn test_generate_simple_function() {
        let mut codegen = JSCodegen::new();

        let mut function = IRFunction::new("add".to_string(), IRType::Int);
        function.add_param("a".to_string(), IRType::Int);
        function.add_param("b".to_string(), IRType::Int);
        function.add_local("result".to_string(), IRType::Int);

        // Simplified body - in reality this would be more complex
        function.add_instruction(IRInstruction::Return);

        let js_code = codegen.generate_function(&function);

        assert!(js_code.contains("function add(a, b)"));
        assert!(js_code.contains("let result: number;"));
    }

    #[test]
    fn test_generate_expressions() {
        let mut codegen = JSCodegen::new();

        // Test binary operation
        let expr = IRExpr::BinaryOp(
            BinaryOp::Add,
            Box::new(IRExpr::Const(Value::Int(1))),
            Box::new(IRExpr::Const(Value::Int(2)))
        );

        let js_code = codegen.generate_expression(&expr);
        assert_eq!(js_code, "(1 + 2)");
    }

    #[test]
    fn test_type_conversion() {
        let codegen = JSCodegen::new();

        assert_eq!(codegen.type_to_js(&IRType::Int), "number");
        assert_eq!(codegen.type_to_js(&IRType::String), "string");
        assert_eq!(codegen.type_to_js(&IRType::Bool), "boolean");
        assert_eq!(codegen.type_to_js(&IRType::Array(Box::new(IRType::Int))), "number[]");
    }
}