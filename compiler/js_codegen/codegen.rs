//! JavaScript Code Generator Implementation
//!
//! Converts Vela IR to JavaScript code

use std::collections::HashMap;
use crate::ir::{
    IRModule, IRFunction, IRInstruction, IRExpr, IRType, Value,
    BinaryOp, UnaryOp, IRParam, IRLocal, IRGlobal
};

/// Main JavaScript code generator
pub struct JSCodegen {
    indent_level: usize,
    in_function: bool,
    variables: HashMap<String, String>, // name -> js_name
    stack: Vec<String>, // Virtual stack for expression evaluation
    skip_ternary_instructions: usize, // Number of instructions to skip (for ternary patterns)
    in_else_context: bool, // Whether the next if should be else if
}

impl JSCodegen {
    pub fn new() -> Self {
        Self {
            indent_level: 0,
            in_function: false,
            variables: HashMap::new(),
            stack: Vec::new(),
            skip_ternary_instructions: 0,
            in_else_context: false,
        }
    }

    /// Generate JavaScript code for a complete module
    pub fn generate_module(&mut self, module: &IRModule) -> String {
        let mut output = String::new();

        // Add runtime imports
        output.push_str("// Generated by Vela JS Codegen\n");
        output.push_str("// Runtime: vela-runtime.js\n");
        output.push_str(&format!("// Module: {}\n\n", module.name));

        // Generate globals
        for global in &module.globals {
            output.push_str(&self.generate_global(global));
            output.push_str("\n");
        }

        if !module.globals.is_empty() {
            output.push_str("\n");
        }

        // Generate functions
        for function in &module.functions {
            output.push_str(&self.generate_function(function));
            output.push_str("\n\n");
        }

        output
    }

    /// Generate JavaScript code for a function
    pub fn generate_function(&mut self, function: &IRFunction) -> String {
        self.in_function = true;
        self.variables.clear();

        let mut output = String::new();

        // Function signature
        if function.is_async {
            output.push_str("async ");
        }
        output.push_str("function ");
        output.push_str(&function.name);
        output.push_str("(");

        // Parameters
        let params: Vec<String> = function.params.iter()
            .map(|p| p.name.clone())
            .collect();
        output.push_str(&params.join(", "));

        output.push_str(") {\n");

        self.indent_level += 1;

        // Local variables
        for local in &function.locals {
            let indent = self.get_indent();
            let js_type = self.type_to_js(&local.ty);
            output.push_str(&format!("{}let {}: {};\n", indent, local.name, js_type));
        }

        if !function.locals.is_empty() {
            output.push_str("\n");
        }

        // Generate function body
        output.push_str(&self.generate_function_body(&function.body));

        self.indent_level -= 1;
        output.push_str("}\n");

        self.in_function = false;
        output
    }

    /// Generate function body from IR instructions
    fn generate_function_body(&mut self, instructions: &[IRInstruction]) -> String {
        let mut output = String::new();
        let mut i = 0;
        let mut temp_var_counter = 0;

        // Debug: print all instructions
        println!("DEBUG: Processing {} instructions", instructions.len());
        for (idx, instr) in instructions.iter().enumerate() {
            println!("DEBUG: Instruction {}: {:?}", idx, instr);
        }

        while i < instructions.len() {
            match &instructions[i] {
                IRInstruction::DeclareVar { name, ty } => {
                    let indent = self.get_indent();
                    let js_type = self.type_to_js(ty);
                    output.push_str(&format!("{}let {}: {};\n", indent, name, js_type));
                }

                IRInstruction::AssignVar { name, value } => {
                    let indent = self.get_indent();
                    let expr = self.generate_expression(value);
                    output.push_str(&format!("{}{} = {};\n", indent, name, expr));
                }

                IRInstruction::LoadConst(value) => {
                    // Push constant value to virtual stack
                    let js_value = self.generate_value(value);
                    self.stack.push(js_value.clone());
                    println!("DEBUG: LoadConst - pushed '{}' to stack", js_value);
                }

                IRInstruction::LoadVar(name) => {
                    // Push variable to virtual stack
                    self.stack.push(name.clone());
                    println!("DEBUG: LoadVar - pushed '{}' to stack", name);
                }

                IRInstruction::StoreVar(name) => {
                    // Pop value from stack and assign to variable
                    if let Some(value) = self.stack.pop() {
                        let indent = self.get_indent();
                        output.push_str(&format!("{}{} = {};\n", indent, name, value));
                    }
                }

                IRInstruction::BinaryOp(op) => {
                    // For simple expressions, generate inline. For complex cases (like ternary), use temp vars
                    if let (Some(right), Some(left)) = (self.stack.pop(), self.stack.pop()) {
                        println!("DEBUG: BinaryOp - popped '{}' and '{}' from stack", left, right);
                        // Check if this is part of a control flow that needs temp vars
                        let needs_temp_var = self.needs_temp_var_for_binary_op(i, instructions);

                        if needs_temp_var {
                            let temp_var = format!("_temp{}", temp_var_counter);
                            temp_var_counter += 1;

                            // Optimize 0 - x to -x
                            let expr = if left == "0" && matches!(op, BinaryOp::Sub) {
                                format!("-{}", right)
                            } else {
                                let op_js = self.binary_op_to_js(op);
                                format!("({} {} {})", left, op_js, right)
                            };

                            let indent = self.get_indent();
                            output.push_str(&format!("{}let {} = {};\n", indent, temp_var, expr));
                            self.stack.push(temp_var.clone());
                            println!("DEBUG: BinaryOp - generated temp var '{}' with expr '{}'", temp_var, expr);
                        } else {
                            // Generate inline expression
                            let op_js = self.binary_op_to_js(op);
                            let expr = if left == "0" && matches!(op, BinaryOp::Sub) {
                                format!("-{}", right)
                            } else {
                                format!("({} {} {})", left, op_js, right)
                            };
                            self.stack.push(expr.clone());
                            println!("DEBUG: BinaryOp - generated inline expr '{}'", expr);
                        }
                    } else {
                        println!("DEBUG: BinaryOp - ERROR: not enough values on stack");
                    }
                }

                IRInstruction::UnaryOp(op) => {
                    // For simple expressions, generate inline. For complex cases (like ternary), use temp vars
                    if let Some(operand) = self.stack.pop() {
                        println!("DEBUG: UnaryOp - popped '{}' from stack", operand);
                        let needs_temp_var = self.needs_temp_var_for_unary_op(i, instructions);

                        if needs_temp_var {
                            let op_js = self.unary_op_to_js(op);
                            let temp_var = format!("_temp{}", temp_var_counter);
                            temp_var_counter += 1;
                            let indent = self.get_indent();
                            output.push_str(&format!("{}let {} = {}{};\n", indent, temp_var, op_js, operand));
                            self.stack.push(temp_var.clone());
                            println!("DEBUG: UnaryOp - generated temp var '{}' with expr '{}{}'", temp_var, op_js, operand);
                        } else {
                            // Generate inline expression
                            let op_js = self.unary_op_to_js(op);
                            let expr = format!("{}{}", op_js, operand);
                            self.stack.push(expr.clone());
                            println!("DEBUG: UnaryOp - generated inline expr '{}'", expr);
                        }
                    } else {
                        println!("DEBUG: UnaryOp - ERROR: no operand on stack");
                    }
                }

                IRInstruction::Call { function, arg_count } => {
                    // Pop arguments from stack
                    let mut args = Vec::new();
                    for _ in 0..*arg_count {
                        if let Some(arg) = self.stack.pop() {
                            args.push(arg);
                        }
                    }
                    args.reverse(); // Stack is LIFO, so reverse to get correct order

                    let indent = self.get_indent();
                    let args_str = args.join(", ");
                    let temp_var = format!("_temp{}", temp_var_counter);
                    temp_var_counter += 1;
                    output.push_str(&format!("{}let {} = {}({});\n", indent, temp_var, function, args_str));
                    self.stack.push(temp_var);
                }

                IRInstruction::Return => {
                    println!("DEBUG: Return - stack contents: {:?}", self.stack);
                    let indent = self.get_indent();
                    if let Some(value) = self.stack.pop() {
                        output.push_str(&format!("{}return {};\n", indent, value));
                        println!("DEBUG: Return - returning '{}'", value);
                    } else {
                        output.push_str(&format!("{}return;\n", indent));
                        println!("DEBUG: Return - returning void");
                    }
                }

                IRInstruction::Label(label) => {
                    // For control flow, generate else or else if
                    if label == "else1" {
                        self.in_else_context = true;
                        // Don't generate code here, let the next JumpIf handle the else if
                    } else if label == "else2" {
                        // This is the final else block
                        let indent = self.get_indent();
                        output.push_str(&format!("{}}} else {{\n", indent));
                        self.indent_level += 1;
                    } else if label == "else_ternary" || label == "end_ternary" {
                        // Skip indent operations for ternary expressions
                    } else if label == "end" {
                        // End label, no special handling needed
                    }
                }

                IRInstruction::Jump(label) => {
                    // For control flow, Jump("end") closes the current block
                    if label == "end" {
                        self.indent_level -= 1;
                        let indent = self.get_indent();
                        output.push_str(&format!("{}}}\n", indent));
                    } else if label == "end_ternary" {
                        self.indent_level -= 1;
                        let indent = self.get_indent();
                        output.push_str(&format!("{}}} else {{\n", indent));
                        self.indent_level += 1;
                    } else {
                        let indent = self.get_indent();
                        output.push_str(&format!("{}goto {};\n", indent, label));
                    }
                }

                IRInstruction::JumpIf(label) => {
                    // Check if this is a ternary pattern: JumpIf -> LoadConst/LoadVar -> Jump -> Label -> LoadConst/LoadVar -> Label
                    let is_ternary_pattern = self.is_ternary_pattern(i, instructions);

                    if is_ternary_pattern {
                        // Generate ternary expression directly on stack
                        if let Some(condition) = self.stack.pop() {
                            println!("DEBUG: JumpIf - detected ternary pattern with condition '{}'", condition);

                            // Get the then and else values
                            let then_value = self.extract_ternary_branch_value(i + 1, instructions);
                            let else_value = self.extract_ternary_branch_value(i + 4, instructions);

                            let ternary_expr = format!("({} ? {} : {})", condition, then_value, else_value);
                            self.stack.push(ternary_expr.clone());
                            println!("DEBUG: JumpIf - generated ternary expr '{}'", ternary_expr);

                            // Skip the next 6 instructions (LoadConst, Jump, Label, LoadConst, Label)
                            self.skip_ternary_instructions = 6;
                        } else {
                            println!("DEBUG: JumpIf - ERROR: no condition on stack for ternary");
                        }
                    } else {
                        // Pop condition from stack and generate if statement
                        if let Some(condition) = self.stack.pop() {
                            println!("DEBUG: JumpIf - popped condition '{}' from stack", condition);
                            let indent = self.get_indent();
                            // If condition is already wrapped in parentheses (inline expression), don't add extra parentheses
                            let condition_str = if condition.starts_with('(') && condition.ends_with(')') {
                                condition
                            } else {
                                format!("({})", condition)
                            };
                            
                            if self.in_else_context {
                                output.push_str(&format!("{}}} else if {} {{\n", indent, condition_str));
                                self.in_else_context = false; // Reset the flag
                            } else {
                                output.push_str(&format!("{}if {} {{\n", indent, condition_str));
                            }
                            self.indent_level += 1;
                        } else {
                            println!("DEBUG: JumpIf - ERROR: no condition on stack");
                        }
                    }
                }

                IRInstruction::CreateArray { element_type: _, size } => {
                    let indent = self.get_indent();
                    let temp_var = format!("_temp{}", temp_var_counter);
                    temp_var_counter += 1;
                    output.push_str(&format!("{}let {} = new Array({});\n", indent, temp_var, size));
                    self.stack.push(temp_var);
                }

                IRInstruction::ArrayAccess => {
                    if let (Some(index), Some(array)) = (self.stack.pop(), self.stack.pop()) {
                        let result = format!("{}[{}]", array, index);
                        self.stack.push(result);
                    }
                }

                IRInstruction::ArrayStore => {
                    if let (Some(value), Some(index), Some(array)) = (self.stack.pop(), self.stack.pop(), self.stack.pop()) {
                        let indent = self.get_indent();
                        output.push_str(&format!("{}{}[{}] = {};\n", indent, array, index, value));
                    }
                }

                IRInstruction::CreateObject(type_name) => {
                    let indent = self.get_indent();
                    let temp_var = format!("_temp{}", temp_var_counter);
                    temp_var_counter += 1;
                    output.push_str(&format!("{}let {} = new {}();\n", indent, temp_var, type_name));
                    self.stack.push(temp_var);
                }

                IRInstruction::PropertyAccess(property) => {
                    if let Some(object) = self.stack.pop() {
                        let result = format!("{}.{}", object, property);
                        self.stack.push(result);
                    }
                }

                IRInstruction::PropertyStore(property) => {
                    if let (Some(value), Some(object)) = (self.stack.pop(), self.stack.pop()) {
                        let indent = self.get_indent();
                        output.push_str(&format!("{}{}.{} = {};\n", indent, object, property, value));
                    }
                }
            }

            // Skip ternary instructions if needed
            if self.skip_ternary_instructions > 0 {
                i += self.skip_ternary_instructions;
                self.skip_ternary_instructions = 0;
            } else {
                i += 1;
            }
        }

        output
    }

    /// Generate JavaScript code for an expression
    pub fn generate_expression(&mut self, expr: &IRExpr) -> String {
        match expr {
            IRExpr::Var(name) => name.clone(),
            IRExpr::Const(value) => self.generate_value(value),
            IRExpr::BinaryOp(op, left, right) => {
                let left_js = self.generate_expression(left);
                let right_js = self.generate_expression(right);
                let op_js = self.binary_op_to_js(op);
                format!("({} {} {})", left_js, op_js, right_js)
            }
            IRExpr::UnaryOp(op, expr) => {
                let expr_js = self.generate_expression(expr);
                let op_js = self.unary_op_to_js(op);
                format!("({}{})", op_js, expr_js)
            }
            IRExpr::Call { function, args } => {
                let args_js: Vec<String> = args.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect();
                format!("{}({})", function, args_js.join(", "))
            }
            IRExpr::ArrayAccess { array, index } => {
                let array_js = self.generate_expression(array);
                let index_js = self.generate_expression(index);
                format!("{}[{}]", array_js, index_js)
            }
            IRExpr::PropertyAccess { object, property } => {
                let object_js = self.generate_expression(object);
                format!("{}.{}", object_js, property)
            }
        }
    }

    /// Generate JavaScript code for a value
    fn generate_value(&self, value: &Value) -> String {
        match value {
            Value::Bool(b) => b.to_string(),
            Value::Int(i) => i.to_string(),
            Value::Float(f) => f.to_string(),
            Value::String(s) => format!("\"{}\"", s),
            Value::Null => "null".to_string(),
        }
    }

    /// Generate JavaScript code for a global variable
    fn generate_global(&mut self, global: &IRGlobal) -> String {
        let mut output = format!("let {}: {}", global.name, self.type_to_js(&global.ty));

        if let Some(initial) = &global.initial_value {
            output.push_str(&format!(" = {}", self.generate_value(initial)));
        }

        output.push(';');
        output
    }

    /// Convert IR type to JavaScript type annotation
    pub fn generate_type(&mut self, ty: &IRType) -> String {
        self.type_to_js(ty)
    }

    /// Convert IR type to JavaScript type string
    fn type_to_js(&self, ty: &IRType) -> String {
        match ty {
            IRType::Void => "void".to_string(),
            IRType::Bool => "boolean".to_string(),
            IRType::Int => "number".to_string(),
            IRType::Float => "number".to_string(),
            IRType::String => "string".to_string(),
            IRType::Array(element_type) => format!("{}[]", self.type_to_js(element_type)),
            IRType::Object(name) => name.clone(),
        }
    }

    /// Convert binary operator to JavaScript
    fn binary_op_to_js(&self, op: &BinaryOp) -> &'static str {
        match op {
            BinaryOp::Add => "+",
            BinaryOp::Sub => "-",
            BinaryOp::Mul => "*",
            BinaryOp::Div => "/",
            BinaryOp::Mod => "%",
            BinaryOp::Eq => "===",
            BinaryOp::Ne => "!==",
            BinaryOp::Lt => "<",
            BinaryOp::Le => "<=",
            BinaryOp::Gt => ">",
            BinaryOp::Ge => ">=",
            BinaryOp::And => "&&",
            BinaryOp::Or => "||",
        }
    }

    /// Convert unary operator to JavaScript
    fn unary_op_to_js(&self, op: &UnaryOp) -> &'static str {
        match op {
            UnaryOp::Neg => "-",
            UnaryOp::Not => "!",
        }
    }

    /// Get current indentation string
    fn get_indent(&self) -> String {
        "  ".repeat(self.indent_level)
    }

    /// Check if a binary operation needs a temporary variable (for complex control flow)
    fn needs_temp_var_for_binary_op(&self, current_index: usize, instructions: &[IRInstruction]) -> bool {
        // If the next instruction is JumpIf, we want inline expressions for cleaner if statements
        // But for other cases, use temp vars to avoid complex expressions
        if current_index + 1 < instructions.len() {
            !matches!(instructions[current_index + 1], IRInstruction::JumpIf(_))
        } else {
            true // Use temp var at end of instructions
        }
    }

    /// Check if a unary operation needs a temporary variable (for complex control flow)
    fn needs_temp_var_for_unary_op(&self, current_index: usize, instructions: &[IRInstruction]) -> bool {
        // If the next instruction is JumpIf, we want inline expressions for cleaner if statements
        // But for other cases, use temp vars to avoid complex expressions
        if current_index + 1 < instructions.len() {
            !matches!(instructions[current_index + 1], IRInstruction::JumpIf(_))
        } else {
            true // Use temp var at end of instructions
        }
    }

    /// Check if the current JumpIf starts a ternary pattern
    fn is_ternary_pattern(&self, current_index: usize, instructions: &[IRInstruction]) -> bool {
        if current_index + 5 >= instructions.len() {
            return false;
        }

        // Check the exact pattern: JumpIf(else) -> LoadConst/LoadVar -> Jump(end) -> Label(else) -> LoadConst/LoadVar -> Label(end)
        match (&instructions[current_index], &instructions[current_index + 1], &instructions[current_index + 2],
               &instructions[current_index + 3], &instructions[current_index + 4], &instructions[current_index + 5]) {
            (IRInstruction::JumpIf(cond_label), IRInstruction::LoadConst(_) | IRInstruction::LoadVar(_),
             IRInstruction::Jump(end_label), IRInstruction::Label(else_label),
             IRInstruction::LoadConst(_) | IRInstruction::LoadVar(_), IRInstruction::Label(final_label)) => {
                // The labels must form the correct ternary pattern: condition jumps to else, jump goes to end
                // and the labels match: else_label == cond_label and final_label == end_label
                else_label == cond_label && final_label == end_label
            }
            _ => false,
        }
    }

    /// Extract the value from a ternary branch (LoadConst or LoadVar)
    fn extract_ternary_branch_value(&self, index: usize, instructions: &[IRInstruction]) -> String {
        match &instructions[index] {
            IRInstruction::LoadConst(value) => self.generate_value(value),
            IRInstruction::LoadVar(name) => name.clone(),
            _ => "undefined".to_string(), // Should not happen if is_ternary_pattern is correct
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ir::{IRModule, IRFunction, IRInstruction, IRExpr, IRType, Value};

    #[test]
    fn test_generate_simple_function() {
        let mut codegen = JSCodegen::new();

        let mut function = IRFunction::new("add".to_string(), IRType::Int);
        function.add_param("a".to_string(), IRType::Int);
        function.add_param("b".to_string(), IRType::Int);
        function.add_local("result".to_string(), IRType::Int);

        // Simplified body - in reality this would be more complex
        function.add_instruction(IRInstruction::Return);

        let js_code = codegen.generate_function(&function);

        assert!(js_code.contains("function add(a, b)"));
        assert!(js_code.contains("let result: number;"));
    }

    #[test]
    fn test_generate_expressions() {
        let mut codegen = JSCodegen::new();

        // Test binary operation
        let expr = IRExpr::BinaryOp(
            BinaryOp::Add,
            Box::new(IRExpr::Const(Value::Int(1))),
            Box::new(IRExpr::Const(Value::Int(2)))
        );

        let js_code = codegen.generate_expression(&expr);
        assert_eq!(js_code, "(1 + 2)");
    }

    #[test]
    fn test_type_conversion() {
        let codegen = JSCodegen::new();

        assert_eq!(codegen.type_to_js(&IRType::Int), "number");
        assert_eq!(codegen.type_to_js(&IRType::String), "string");
        assert_eq!(codegen.type_to_js(&IRType::Bool), "boolean");
        assert_eq!(codegen.type_to_js(&IRType::Array(Box::new(IRType::Int))), "number[]");
    }
}