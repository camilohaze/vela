# Ejemplo PrÃ¡ctico: InstalaciÃ³n de un Binding

Este ejemplo muestra exactamente quÃ© sucede cuando ejecutas `vela install lodash`.

## ğŸ¯ Comando Ejecutado

```bash
vela install lodash
```

## ğŸ“¦ QuÃ© se Descarga

El comando descarga un **paquete Vela** que contiene:

```
vela_modules/lodash/
â”œâ”€â”€ vela.yaml          # Metadata del paquete Vela
â”œâ”€â”€ README.md          # DocumentaciÃ³n
â”œâ”€â”€ index.vela         # â† EL ARCHIVO QUE VELA LEE
â””â”€â”€ generated/         # CÃ³digo generado (no se lee)
    â””â”€â”€ glue.js        # CÃ³digo glue generado automÃ¡ticamente
```

## ğŸ” Contenido Real del Archivo que Vela Lee

### **index.vela** (Archivo .vela puro)

```vela
"""
Binding for lodash JavaScript library
Version: 4.17.21
Generated: 2025-12-10
"""

@js_binding("lodash")
module Lodash {
  """
  Pure functional interface to lodash.
  All functions are @pure and have no side effects.
  """

  @pure
  fn chunk<T>(array: List<T>, size: Number) -> List<List<T>> {
    """
    Creates an array of elements split into groups the length of size.
    """
  }

  @pure
  fn flatten<T>(array: List<List<T>>) -> List<T> {
    """
    Flattens array a single level deep.
    """
  }

  @pure
  fn uniq<T>(array: List<T>) -> List<T> {
    """
    Creates a duplicate-free version of an array.
    """
  }

  @pure
  fn groupBy<T, K>(array: List<T>, iteratee: (T) -> K) -> Dict<K, List<T>> {
    """
    Creates an object composed of keys generated from the results of running
    each element of array thru iteratee.
    """
  }
}
```

**Este es el ÃšNICO archivo que Vela lee y compila.**

## ğŸš« QuÃ© NO se Incluye

### **NO hay archivos JS que Vela lea:**

```javascript
// âŒ lodash.js original - Vela NUNCA lee esto
function chunk(array, size) {
  // Implementation details...
}

// âŒ CÃ³digo JS manual - Vela NUNCA lee esto
const _ = require('lodash');
module.exports = { chunk: _.chunk };
```

### **NO hay imports directos:**

```javascript
// âŒ Vela NO permite esto
import * as lodash from 'lodash'; // Syntax error
```

## âš™ï¸ QuÃ© Genera el Compilador

### **glue.js** (Generado automÃ¡ticamente)

```javascript
// Generated by Vela compiler - DO NOT EDIT
// Generated from: vela_modules/lodash/index.vela
// Timestamp: 2025-12-10T10:30:00Z

const lodash = require('lodash');

function vela_lodash_chunk(array, size) {
  // Type checking generated by Vela
  if (!Array.isArray(array)) {
    throw new Error('Expected List<T>, got: ' + typeof array);
  }
  if (typeof size !== 'number') {
    throw new Error('Expected Number, got: ' + typeof size);
  }

  // Call to external library
  return lodash.chunk(array, size);
}

function vela_lodash_flatten(array) {
  if (!Array.isArray(array)) {
    throw new Error('Expected List<List<T>>');
  }
  return lodash.flatten(array);
}

function vela_lodash_uniq(array) {
  if (!Array.isArray(array)) {
    throw new Error('Expected List<T>');
  }
  return lodash.uniq(array);
}

function vela_lodash_groupBy(array, iteratee) {
  if (!Array.isArray(array)) {
    throw new Error('Expected List<T>');
  }
  if (typeof iteratee !== 'function') {
    throw new Error('Expected function');
  }
  return lodash.groupBy(array, iteratee);
}

module.exports = {
  vela_lodash_chunk,
  vela_lodash_flatten,
  vela_lodash_uniq,
  vela_lodash_groupBy
};
```

## ğŸ”„ Proceso de CompilaciÃ³n

### **1. Parse del Binding**

```rust
// src/compiler/bindings/parser.rs
pub fn parse_binding(file_path: &Path) -> Result<Binding, Error> {
    let content = fs::read_to_string(file_path)?; // Lee index.vela
    let ast = parse_vela_source(&content)?;       // Parse como Vela normal
    validate_pure_contracts(ast)?;                // Verifica @pure
    Ok(Binding::from_ast(ast))
}
```

### **2. GeneraciÃ³n de Glue Code**

```rust
// src/compiler/bindings/generator.rs
pub fn generate_glue_code(binding: &Binding) -> String {
    let mut code = format!("const {} = require('{}');\n\n",
                          binding.library, binding.library);

    for func in &binding.functions {
        code.push_str(&generate_function_wrapper(func));
    }

    code.push_str("module.exports = {\n");
    for func in &binding.functions {
        code.push_str(&format!("  vela_{}_{},\n",
                              binding.library, func.name));
    }
    code.push_str("};\n");

    code
}
```

### **3. Link en Runtime**

```javascript
// runtime/js/interop.js
const glue = require('./generated/glue');
const lodash = require('lodash');

// Vela VM calls this
function call_binding(library, function_name, args) {
  const glue_fn = glue[`vela_${library}_${function_name}`];
  return glue_fn.apply(null, args);
}
```

## ğŸ“ Uso en CÃ³digo Vela

### **CÃ³digo Vela (main.vela)**

```vela
// Importa el binding (lee index.vela)
import 'bindings:lodash'

// Usa como funciÃ³n pura normal
fn processData(data: List<Number>) -> List<List<Number>> {
  // Llama al contrato puro definido en index.vela
  chunks = Lodash.chunk(data, 3)

  // El compilador sabe que esto es puro y puede optimizar
  return chunks.filter(chunk => chunk.length > 0)
}
```

### **CÃ³digo Compilado (JS Backend)**

```javascript
// Generated by Vela compiler
const glue = require('./glue');

function processData(data) {
  // Call to binding (goes through glue code)
  const chunks = glue.vela_lodash_chunk(data, 3);

  // Pure functional operations
  return chunks.filter(chunk => chunk.length > 0);
}
```

## ğŸ¯ ConclusiÃ³n

Cuando instalas un binding:

1. **Descargas**: Un paquete con `index.vela` (contrato puro)
2. **Compilas**: Vela lee `index.vela` y genera `glue.js`
3. **Ejecutas**: El runtime usa el glue code para llamar a librerÃ­as externas

**Vela nunca lee archivos JS directamente.** Los bindings son contratos funcionales puros escritos en Vela.